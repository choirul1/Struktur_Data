{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Struktur Data \"Python\" Nama : Ach. Choirul Umam Nim : 160411100075 Dosen Pengampu : Dr. Indah Agustien Siradjudin. S.Kom., M.Kom Universitas Trunojoyo Madura","title":"Pendahuluan"},{"location":"#struktur-data-python","text":"Nama : Ach. Choirul Umam Nim : 160411100075 Dosen Pengampu : Dr. Indah Agustien Siradjudin. S.Kom., M.Kom Universitas Trunojoyo Madura","title":"Struktur Data \"Python\""},{"location":"Profil/","text":"Nama : Ach. Choirul Umam Nim : 160411100075 Dosen Pengampu : Dr. Indah Agustien Siradjudin. S.Kom., M.Kom Universitas Trunojoyo Madura \u200b","title":"Profil"},{"location":"materi1/","text":"Stack A. Definisi Stacks adalah satu struktur data dimana penambahan dan penghapusan data, hanya dapat dilakukan pada satu ujung yang sama , atau yang biasa dikenal dengan istilah top . Semakin data jauh berada dari posisi top, maka data tersebut diindikasikan berada di stack lebih lama dibandingkan dengan data yang berada dekat pada data di posisi top. Jika terdapat data baru yang ditambahkan di stack, maka data ini pulalah yang akan dihapus ketika terdapat proses penghapusan data. Konsep ini dikenal dengan nama LIFO-Last In First Out . B. Ilustrasi Jika Ingin Melakukan Perubahan Susunan Balok Diatas, Maka Yang Dapat Diambil Adalah Balok paling atas, sama halnya ketika ingin mengambil balok paling bawah, maka harus mengambil balok-balok yang berada diatasnya terlebih dahulu. C. Operasi Stack stack() membuat suatu stack baru yang kosong. Tidak memerlukan parameter dan mengembalikan suatu stack kosong. push(item) menambahkan suatu item baru ke atas (top) dari stack. Perlu item dan tidak mengembalikan apapun. pop() menghapus item teratas dari stack. Tidak perlu parameter dan mengembalikan item. Stack berubah. peek() mengembalikan top item dari stack tetapi tidak menghapusnya. Tidak memerlukan parameter dan stack tidak berubah. isEmpty() memeriksa apakah stack dalam keadaan kosong. Tidak memerlukan parameter dan mengembalikan nilai boolean. size() mengembalikan jumlah item di dalam stack. Tidak memerlukan parameter dan mengembalikan suatu integer. D. Code Dibawah ini merupakan fungsi-fungsi untuk implementasi stack def stack(): s=[] return (s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return(len(s)) Berikut Contoh Implementasi Sederhana : st=stack() isEmpty(st) Output : True push(st,5) push(st,4) push(st,3) pop(st) push(st,10) pop(st) print(st) Output : [5, 4] E. Latihan Program Balik Kata def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def balik(teks): a=stack() hasil ='' for i in range(len(teks)): push(a, teks[i]) for i in range (len(teks)): hasil=hasil+pop(a) return hasil print(balik('arek')) Output: kera Program Konversi bilangan desimal ke bilangan biner Konversi Bilangan Sangat Diperlukan Dalam dunia komputer, bahkan sangat di butuhkan ketika akan mengkonversi bilangan untuk satu alamat IP Jaringan. def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def biner(desi): st=stack() des=desi while des>0: push(st,str(des%2)) des=des//2 hasil='' while not isEmpty(st): if len(st)==1: hasil=hasil+st.pop() else: hasil=hasil+st.pop()+\".\" return(hasil) s=int(input(\"masukkan nilai desimal:\")) print(\"biner:\"+biner(s)) masukkan nilai desimal:234 biner:1.1.1.0.1.0.1.0 Output masukkan nilai desimal: 234 biner: 1.1.1.0.1.0.1.0","title":"Materi 1 Stack"},{"location":"materi1/#stack","text":"","title":"Stack"},{"location":"materi1/#a-definisi","text":"Stacks adalah satu struktur data dimana penambahan dan penghapusan data, hanya dapat dilakukan pada satu ujung yang sama , atau yang biasa dikenal dengan istilah top . Semakin data jauh berada dari posisi top, maka data tersebut diindikasikan berada di stack lebih lama dibandingkan dengan data yang berada dekat pada data di posisi top. Jika terdapat data baru yang ditambahkan di stack, maka data ini pulalah yang akan dihapus ketika terdapat proses penghapusan data. Konsep ini dikenal dengan nama LIFO-Last In First Out .","title":"A. Definisi"},{"location":"materi1/#b-ilustrasi","text":"Jika Ingin Melakukan Perubahan Susunan Balok Diatas, Maka Yang Dapat Diambil Adalah Balok paling atas, sama halnya ketika ingin mengambil balok paling bawah, maka harus mengambil balok-balok yang berada diatasnya terlebih dahulu. C. Operasi Stack stack() membuat suatu stack baru yang kosong. Tidak memerlukan parameter dan mengembalikan suatu stack kosong. push(item) menambahkan suatu item baru ke atas (top) dari stack. Perlu item dan tidak mengembalikan apapun. pop() menghapus item teratas dari stack. Tidak perlu parameter dan mengembalikan item. Stack berubah. peek() mengembalikan top item dari stack tetapi tidak menghapusnya. Tidak memerlukan parameter dan stack tidak berubah. isEmpty() memeriksa apakah stack dalam keadaan kosong. Tidak memerlukan parameter dan mengembalikan nilai boolean. size() mengembalikan jumlah item di dalam stack. Tidak memerlukan parameter dan mengembalikan suatu integer. D. Code Dibawah ini merupakan fungsi-fungsi untuk implementasi stack def stack(): s=[] return (s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return(len(s)) Berikut Contoh Implementasi Sederhana : st=stack() isEmpty(st) Output : True push(st,5) push(st,4) push(st,3) pop(st) push(st,10) pop(st) print(st) Output : [5, 4] E. Latihan Program Balik Kata def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def balik(teks): a=stack() hasil ='' for i in range(len(teks)): push(a, teks[i]) for i in range (len(teks)): hasil=hasil+pop(a) return hasil print(balik('arek')) Output: kera Program Konversi bilangan desimal ke bilangan biner Konversi Bilangan Sangat Diperlukan Dalam dunia komputer, bahkan sangat di butuhkan ketika akan mengkonversi bilangan untuk satu alamat IP Jaringan. def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def biner(desi): st=stack() des=desi while des>0: push(st,str(des%2)) des=des//2 hasil='' while not isEmpty(st): if len(st)==1: hasil=hasil+st.pop() else: hasil=hasil+st.pop()+\".\" return(hasil) s=int(input(\"masukkan nilai desimal:\")) print(\"biner:\"+biner(s)) masukkan nilai desimal:234 biner:1.1.1.0.1.0.1.0 Output masukkan nilai desimal: 234 biner: 1.1.1.0.1.0.1.0","title":"B. Ilustrasi"},{"location":"materi2/","text":"Infix, Prefix dan postfix A. Definisi Infix adalah cara penulisan atau ungkapan yang meletakan operator di tengah antara 2 operand dalam hal ini dalam kurung sangat menentukan posisi. Contoh Infix : A + B ( A - B ) * C Prefix adalah cara penulisan atau ungkapan yang meletakan operator disebelah kiri 2 operand dan dalam kurung sangat menentukan posisi. Contoh Prefix : + A B * - A B C Posfix adalah cara penulisan yang meletakan operator disebelah kanan 2 operand dan posisi operand yang berada di dalam kurung sangat menentukan. Contoh Postfix : A B + A B - C * B. Ilustrasi > Ilustrasi Konversi Infix ke Prefix Contoh : A * B + C proses : infix dibalik menjadi C + B * A Looping Dimulia Karakter Yang Dibaca Isi Stack Karakter Tercetak Hasil Postfix C C C + + B B CB * +* CB A +* A CBA + * CBA* + CBA*+ Hasil Postfix = C B A + * Hasil Postfix dibalik untuk menjadi hasil prefix Hasil Prefix = * + A B C > Ilustrasi Konversi Infix ke Postfix Contoh : A * B + C Proses : Karakter Yang Dibaca Isi Stack Karakter Tercetak Hasil Postfix A A A * * B B AB + + * AB* C + C AB*C + AB*C+ Hasil Postfix = A B * C + Contoh Aritmatik infix dan konversi ke prefix dan postfix Infix Prefix Postfix A + B + A B A B + (A+B)*C *+ABC AB+C* (A+B)*(C-D) *+AB-CD AB+CD-* A+B*C-D -+A*BCD ABC*+D- A+B-C+D +-+ABCD AB+C-D+ A*B - C * D -* AB * CD AB * CD*- C. Algoritma Berikut ini algoritma dari konversi Infix ke Postfix: Buat presisi atau kekuatan operator ( Penjumlahan dan Pengurangan bernilai 2 , Perkalian dan Pembagian bernilai 3 , Kurang buka dan tutup bernilai 1 ) Input data dalam bentuk infix Pisahkan data infix menggunakan split menjadi bentuk List Periksa semua data yang berada di dalam list secara urut mulai dari awal hingga akhir Jika bertemu operand, maka masukan data ke PostfixList untuk dicetak Jika bertemu kurung buka '(' maka masukan ke Stack Operator Jika bertemu kurung tutup ')' maka Stack Operator yang paling atas dan bukan kurung buka '(' diambil untuk dicetak ke PostfixList Jika bertemu operator maka jika Stack Operator tidak kosong dan kekuatan operator yang digunakan lebih kecil dari kekuatan operator yang berada di top Stack Operator maka operator yang berada di Stack Operator diambil (pop) untuk dicetak di PostfixList. lalu masukan operator yang digunakan ke dalam Stack Operator. Begitu seterusnya sampai List yang berisi data Infix habis. Jika Stack Operator masih ada isinya maka ambil dan tambahkan ke PostfixList untuk dicetak. Cetak PostfixList Berikut ini Algoritma dari konversi Infix ke Prefix: Balikan data Infix Jika operator kurung buka '(' maka ganti dengan kurung tutup ')' begitu sebaliknya Masukan data tersebut ke konversi Infix ke Postfix Setelah keluar hasil, Balikan lagi hasil tersebut Maka keluar bentuk Prefix D. Kode Program Berikut ini kode program Konversi dari Infix ke bentuk Postfix : class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) def showList(self): return self.items def infixToPostfix(infixexpr): prec = {} prec[\"*\"] = 3 prec[\"/\"] = 3 prec[\"+\"] = 2 prec[\"-\"] = 2 prec[\"(\"] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() print(tokenList) for token in tokenList: if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\": postfixList.append(token) elif token == '(': opStack.push(token) elif token == ')': topToken = opStack.pop() while topToken != '(': postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and \\ (prec[opStack.peek()] >= prec[token]): postfixList.append(opStack.pop()) opStack.push(token) print('isi postix ',str(postfixList)) while not opStack.isEmpty(): postfixList.append(opStack.pop()) print('isi postix ',str(postfixList)) return \" \".join(postfixList) print(infixToPostfix(\"A * B - C * D\")) print(infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\")) Output : ['A', '*', 'B', '-', 'C', '*', 'D'] ('isi postix ', \"['A']\") ('isi postix ', \"['A']\") ('isi postix ', \"['A', 'B']\") ('isi postix ', \"['A', 'B', '*']\") ('isi postix ', \"['A', 'B', '*', 'C']\") ('isi postix ', \"['A', 'B', '*', 'C']\") ('isi postix ', \"['A', 'B', '*', 'C', 'D']\") ('isi postix ', \"['A', 'B', '*', 'C', 'D', '*', '-']\") A B * C D * - ['(', 'A', '+', 'B', ')', '*', 'C', '-', '(', 'D', '-', 'E', ')', '*', '(', 'F', '+', 'G', ')'] ('isi postix ', '[]') ('isi postix ', \"['A']\") ('isi postix ', \"['A']\") ('isi postix ', \"['A', 'B']\") ('isi postix ', \"['A', 'B', '+']\") ('isi postix ', \"['A', 'B', '+']\") ('isi postix ', \"['A', 'B', '+', 'C']\") ('isi postix ', \"['A', 'B', '+', 'C', '*']\") ('isi postix ', \"['A', 'B', '+', 'C', '*']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F', 'G']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F', 'G', '+']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F', 'G', '+', '*', '-']\") A B + C * D E - F G + * - Berikut Kode Program konversi Infix ke Prefix : class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) def showList(self): return self.items # No 1 def infixToPrefix(infixexpr): prec = {'*':3, '/':3 , '+':2, '-':2 , '(':1} opStack = Stack() prefixList = [] tokenList = infixexpr.split() tokenList.reverse() for i in range(len(tokenList)): if tokenList[i] == '(': tokenList[i]=')' elif tokenList[i] == ')': tokenList[i]='(' for token in tokenList: if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\": prefixList.append(token) elif token == '(': opStack.push(token) elif token == ')': topToken = opStack.pop() while topToken != '(': prefixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and \\ (prec[opStack.peek()] >= prec[token]): prefixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): prefixList.append(opStack.pop()) prefixList = prefixList[::-1] return \" \".join(prefixList) print('No 1') print(infixToPrefix(\"A * B - C * D\")) print(infixToPrefix(\"( A + B ) * C - ( D - E ) * ( F + G )\")) Output : No 1 - * A B * C D - * + A B C * - D E + F G Latihan Praktikum reverseWord (kata) : Gunakan fungsi-fungsi yang terdapat pada modul stack untuk membalik suatu kata. Output dari fungsi reverseWord(kata) ini adalah kata yang sudah disusun secara terbalik, #Ach. choirul Umam #160411100075 #no1 def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def balik(teks): a=stack() hasil ='' for i in range(len(teks)): push(a, teks[i]) for i in range (len(teks)): hasil=hasil+pop(a) return hasil print(balik('madura')) Output : arudam decToBin(num) : Gunakan fungsi-fungsi yang terdapat pada modul stack untuk mengkonversi suatu bilangan decimal menjadi bilangan biner, #Ach. choirul Umam #160411100075 #no2 def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def biner(desi): st=stack() des=desi while des>0: push(st,str(des%2)) des=des//2 hasil='' while not isEmpty(st): if len(st)==1: hasil=hasil+st.pop() else: hasil=hasil+st.pop()+\".\" return(hasil) s=int(input(\"masukkan nilai desimal:\")) print(\"HAsil biner : \"+biner(s)) Output : masukkan nilai desimal:25 HAsil biner : 1.1.0.0.1","title":"Materi 2 infix, prefix, postfix"},{"location":"materi2/#infix-prefix-dan-postfix","text":"","title":"Infix, Prefix dan postfix"},{"location":"materi2/#a-definisi","text":"","title":"A. Definisi"},{"location":"materi2/#infix","text":"adalah cara penulisan atau ungkapan yang meletakan operator di tengah antara 2 operand dalam hal ini dalam kurung sangat menentukan posisi. Contoh Infix : A + B ( A - B ) * C","title":"Infix"},{"location":"materi2/#prefix","text":"adalah cara penulisan atau ungkapan yang meletakan operator disebelah kiri 2 operand dan dalam kurung sangat menentukan posisi. Contoh Prefix : + A B * - A B C","title":"Prefix"},{"location":"materi2/#posfix","text":"adalah cara penulisan yang meletakan operator disebelah kanan 2 operand dan posisi operand yang berada di dalam kurung sangat menentukan. Contoh Postfix : A B + A B - C *","title":"Posfix"},{"location":"materi2/#b-ilustrasi","text":"> Ilustrasi Konversi Infix ke Prefix Contoh : A * B + C proses : infix dibalik menjadi C + B * A Looping Dimulia Karakter Yang Dibaca Isi Stack Karakter Tercetak Hasil Postfix C C C + + B B CB * +* CB A +* A CBA + * CBA* + CBA*+ Hasil Postfix = C B A + * Hasil Postfix dibalik untuk menjadi hasil prefix Hasil Prefix = * + A B C > Ilustrasi Konversi Infix ke Postfix Contoh : A * B + C Proses : Karakter Yang Dibaca Isi Stack Karakter Tercetak Hasil Postfix A A A * * B B AB + + * AB* C + C AB*C + AB*C+ Hasil Postfix = A B * C + Contoh Aritmatik infix dan konversi ke prefix dan postfix Infix Prefix Postfix A + B + A B A B + (A+B)*C *+ABC AB+C* (A+B)*(C-D) *+AB-CD AB+CD-* A+B*C-D -+A*BCD ABC*+D- A+B-C+D +-+ABCD AB+C-D+ A*B - C * D -* AB * CD AB * CD*-","title":"B. Ilustrasi"},{"location":"materi2/#c-algoritma","text":"Berikut ini algoritma dari konversi Infix ke Postfix: Buat presisi atau kekuatan operator ( Penjumlahan dan Pengurangan bernilai 2 , Perkalian dan Pembagian bernilai 3 , Kurang buka dan tutup bernilai 1 ) Input data dalam bentuk infix Pisahkan data infix menggunakan split menjadi bentuk List Periksa semua data yang berada di dalam list secara urut mulai dari awal hingga akhir Jika bertemu operand, maka masukan data ke PostfixList untuk dicetak Jika bertemu kurung buka '(' maka masukan ke Stack Operator Jika bertemu kurung tutup ')' maka Stack Operator yang paling atas dan bukan kurung buka '(' diambil untuk dicetak ke PostfixList Jika bertemu operator maka jika Stack Operator tidak kosong dan kekuatan operator yang digunakan lebih kecil dari kekuatan operator yang berada di top Stack Operator maka operator yang berada di Stack Operator diambil (pop) untuk dicetak di PostfixList. lalu masukan operator yang digunakan ke dalam Stack Operator. Begitu seterusnya sampai List yang berisi data Infix habis. Jika Stack Operator masih ada isinya maka ambil dan tambahkan ke PostfixList untuk dicetak. Cetak PostfixList Berikut ini Algoritma dari konversi Infix ke Prefix: Balikan data Infix Jika operator kurung buka '(' maka ganti dengan kurung tutup ')' begitu sebaliknya Masukan data tersebut ke konversi Infix ke Postfix Setelah keluar hasil, Balikan lagi hasil tersebut Maka keluar bentuk Prefix D. Kode Program Berikut ini kode program Konversi dari Infix ke bentuk Postfix : class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) def showList(self): return self.items def infixToPostfix(infixexpr): prec = {} prec[\"*\"] = 3 prec[\"/\"] = 3 prec[\"+\"] = 2 prec[\"-\"] = 2 prec[\"(\"] = 1 opStack = Stack() postfixList = [] tokenList = infixexpr.split() print(tokenList) for token in tokenList: if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\": postfixList.append(token) elif token == '(': opStack.push(token) elif token == ')': topToken = opStack.pop() while topToken != '(': postfixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and \\ (prec[opStack.peek()] >= prec[token]): postfixList.append(opStack.pop()) opStack.push(token) print('isi postix ',str(postfixList)) while not opStack.isEmpty(): postfixList.append(opStack.pop()) print('isi postix ',str(postfixList)) return \" \".join(postfixList) print(infixToPostfix(\"A * B - C * D\")) print(infixToPostfix(\"( A + B ) * C - ( D - E ) * ( F + G )\")) Output : ['A', '*', 'B', '-', 'C', '*', 'D'] ('isi postix ', \"['A']\") ('isi postix ', \"['A']\") ('isi postix ', \"['A', 'B']\") ('isi postix ', \"['A', 'B', '*']\") ('isi postix ', \"['A', 'B', '*', 'C']\") ('isi postix ', \"['A', 'B', '*', 'C']\") ('isi postix ', \"['A', 'B', '*', 'C', 'D']\") ('isi postix ', \"['A', 'B', '*', 'C', 'D', '*', '-']\") A B * C D * - ['(', 'A', '+', 'B', ')', '*', 'C', '-', '(', 'D', '-', 'E', ')', '*', '(', 'F', '+', 'G', ')'] ('isi postix ', '[]') ('isi postix ', \"['A']\") ('isi postix ', \"['A']\") ('isi postix ', \"['A', 'B']\") ('isi postix ', \"['A', 'B', '+']\") ('isi postix ', \"['A', 'B', '+']\") ('isi postix ', \"['A', 'B', '+', 'C']\") ('isi postix ', \"['A', 'B', '+', 'C', '*']\") ('isi postix ', \"['A', 'B', '+', 'C', '*']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F', 'G']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F', 'G', '+']\") ('isi postix ', \"['A', 'B', '+', 'C', '*', 'D', 'E', '-', 'F', 'G', '+', '*', '-']\") A B + C * D E - F G + * - Berikut Kode Program konversi Infix ke Prefix : class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) def showList(self): return self.items # No 1 def infixToPrefix(infixexpr): prec = {'*':3, '/':3 , '+':2, '-':2 , '(':1} opStack = Stack() prefixList = [] tokenList = infixexpr.split() tokenList.reverse() for i in range(len(tokenList)): if tokenList[i] == '(': tokenList[i]=')' elif tokenList[i] == ')': tokenList[i]='(' for token in tokenList: if token in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" or token in \"0123456789\": prefixList.append(token) elif token == '(': opStack.push(token) elif token == ')': topToken = opStack.pop() while topToken != '(': prefixList.append(topToken) topToken = opStack.pop() else: while (not opStack.isEmpty()) and \\ (prec[opStack.peek()] >= prec[token]): prefixList.append(opStack.pop()) opStack.push(token) while not opStack.isEmpty(): prefixList.append(opStack.pop()) prefixList = prefixList[::-1] return \" \".join(prefixList) print('No 1') print(infixToPrefix(\"A * B - C * D\")) print(infixToPrefix(\"( A + B ) * C - ( D - E ) * ( F + G )\")) Output : No 1 - * A B * C D - * + A B C * - D E + F G Latihan Praktikum reverseWord (kata) : Gunakan fungsi-fungsi yang terdapat pada modul stack untuk membalik suatu kata. Output dari fungsi reverseWord(kata) ini adalah kata yang sudah disusun secara terbalik, #Ach. choirul Umam #160411100075 #no1 def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def balik(teks): a=stack() hasil ='' for i in range(len(teks)): push(a, teks[i]) for i in range (len(teks)): hasil=hasil+pop(a) return hasil print(balik('madura')) Output : arudam decToBin(num) : Gunakan fungsi-fungsi yang terdapat pada modul stack untuk mengkonversi suatu bilangan decimal menjadi bilangan biner, #Ach. choirul Umam #160411100075 #no2 def stack(): s=[] return(s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return (len(s)) def biner(desi): st=stack() des=desi while des>0: push(st,str(des%2)) des=des//2 hasil='' while not isEmpty(st): if len(st)==1: hasil=hasil+st.pop() else: hasil=hasil+st.pop()+\".\" return(hasil) s=int(input(\"masukkan nilai desimal:\")) print(\"HAsil biner : \"+biner(s)) Output : masukkan nilai desimal:25 HAsil biner : 1.1.0.0.1","title":"C. Algoritma"},{"location":"materi3/","text":"Classes A. Definisi class merupakan sebuah objek yang di dalam nya biasanya terdapat beberapa metode yang memang merupakan isi dari sebuah class ini. Class dan metode ini biasa di sebut sebagai (PBO) atau Pemrograman Berorientasi Obyek. Dan (PBO) ini memang fungsinya untuk memudahkan proses atau kegiatan programing. Berikut beberapa hal yang harus diketahui untuk pengenalan Pemrograman Berorientasi Obyek (PBO). 1. String dan List 2. Istilah dalam PBO 3. Constructur 4. Method 5. Overide Method String dan List Merupakan tipe data class yang sudah diketahui dan diginakan sebelumnya, adalah tipe data lists ataupun string. Suatu variabel yang berbentuk lists ataupun string , memiliki dua buah elemen yang terkandung di dalam variabel tersebut, yaitu nilai atau yang disebut dengan state / property , serta method atau fungsi, yang dapat digunakan untuk mengolah nilai pada variabel tersebut. Method atau fungsi yang melekat pada suatu variabel dapat diakses dengan menggunakan syntax. namaObyek.NamaMethod() Contoh : Berikut adalah contoh tipe data string dan lists, yang memiliki nilai sekaligus method. # String dataStr='Choirul' print(dataStr) dataStr=dataStr.upper() print(dataStr) Pada Contoh diatas terdapat variabel dataStr, berbentuk string. dimana property dari dataStr adalah 'Choirul', Contoh method yang digunakan adalah method upper() u p p e r (), yang berfungsi untuk merubah semua karakter pada dataStr d a t a S t r menjadi huruf kapital. Beberapa contoh method lain yang dapat digunakan adalah capitalize() c a p i t a l i z e (), lower() l o w e r (), find() f i n d (), dll # Lists dataLs=[12, 13, 14] print(dataLs) data.append(45) print(dataLs) Pada contoh code diatas, terdapat variabel dataLs d a t a L s yang berbentuk lists . Variabel ini memiliki tiga buah nilai, yaitu 12, 113, dan 14. Contoh method yang digunakan adalah append() a p p e n d (), yaitu menambah data pada variabel berbentuk lists . Contoh method method lain yang dimiliki tipe data lists yang bisa dimanfaatkan, misalkan pop() p o p (), insert() i n s e r t (), clear() c l e a r (), reverse() r e v e r s e (), dsb. Istilah Dalam PBO Kelebihan dari bahasa pemrogaraman berbasis object, adalah bahasa tersebut menyediakan beberapa fitur agar programmer dapat membuat class sendiri yang sesuai dengan kebutuhan. Beberapa istilah dasar yang terdapat pada pemrograman berbasis object ini antara lain : class , tipe data yang tidak hanya berisi data tetapi juga method object , suatu variabel dengan tipe data class state, property , bagian data dari suatu class yang berisi nilai, dapat berupa string, integer, float method , fungsi yang melekat pada class constructor , fungsi yang dijalankan oleh python ketika pertama kali suatu objek dibuat. Method constructor ini dibuat dengan cara mendefinisikan fungsi _ init _ (dua underscore ) self , merupakan suatu argumen atau parameter spesial agar nilai balik dari method dikembalikan ke objek itu sendiri. Argumen ini tidak perlu dipanggil (walaupun sudah didefinisikan)pada saat pemanggilan method instance , suatu objek yang telah dibuat override , mendefinisikan kembali fungsi-fungsi umum yang sudah ada, agar sesuai dengan kebutuhan programmer Constructor Syntax untuk membuat suatu class, adalah sebagai berikut : class namaClass: def _init_() : #constructor def namaMethod () : #Method Sedangkan untuk membuat suatu obyek dengan tipe data class tertentu (proses pembuatan instance ) adalah : namaObyek=namaClass() Constructor merupakan method yang otomatis dijalankan ketika suatu obyek dibuat. Syntax untuk pembuatan constructor ini adalah : def __init__() Contoh : class BilanganKompleks: def __init__(self,a,b): self.real=a self.im=b data=BilanganKompleks(4,6) print(data) untuk menampilkan property atau nilai yang dimiliki oleh suatu obyek, tidak dapat dilakukan dengan syntax print() seperti biasa. Terdapat dua cara agar objek yang sudah dibuat dapat ditampilkan di layar sesuai dengan yang diinginkan, yaitu: Membuat method baru untuk menampilkan data override method standar dari sebuah class Method Method merupakan fungsi-fungsi yang terdapat di dalam suatu class. Contoh method yang akan dibuat adalah method yang berfungsi untuk menampilkan property atau state yang terdapat di dalam suatu obyek. Syntax pembuatan method adalah : def namaMethod(): Sedangkan untuk memanggil method suatu class adalah : namaObyek.namaMethod() Contoh : Berikut adalah contoh pembuatan method display() yang berfungsi untuk menampilkan property yang terdapat pada class Bilangan Kompleks. class BilanganKompleks: def __init__(self,a,b): # constructor self.real=a self.im=b def display(self): # method untuk menampilkan state print (self.real,'+',self.im,'i') data1=BilanganKompleks(4,6) data1.display() data2=BilanganKompleks(2,3) data2.display() Pada contoh code diatas, terdapat method tambahan pada class BilanganKompleks B i l a n g a n K o m p l e k s , yaitu method display() , yang berfungsi untuk menampilkan state atau property obyek dari class BilanganKompleks B i l a n g a n K o m p l e k s . Di dalam method tersebut, digunakan syntax print yang berfungsi untuk menampilkan suatu data. Perintah self.real adalah perintah untuk mengakses state atau property real r e a l , yang dimiliki oleh class BilanganKompleks B i l a n g a n K o m p l e k s , begitu juga dengan perintah self.im , digunakan untuk mengakses property im i m . Karena property real r e a l dan im i m bertipe data integer, maka syntax print() dapat dilakukan pada dua property tersebut 5. Override Method Override Method merupakan penambahan fungsi-fungsi pada syntax-syntax yang sudah ada. Seperti yang dijelaskan sebelumnya, untuk menampilkan property yang terdapat pada suatu obyek, tidak dapat dilakukan dengan menggunakan perintah print() . Cara pertama yang sudah dijelaskan adalah membuat method baru di dalam class, yang berfungsi untuk menampilkan property suatu class. Cara kedua adalah dengan cara override method fungsi yang sudah tersedia oleh bahasa pemrograman. Syntax yang akan di override adalah syntax print() . Yang perlu dilakukan agar suatu object dapat dipanggil dengan perintah print adalah object tersebut harus dirubah menjadi string. Untuk merubah suatu variabel menjadi string, maka suatu class dilengkapi dengan method __str__ . Hanya saja method ini tidak bisa berfungsi secara sempurna sesuai dengan apa yang diinginkan oleh programmer, yaitu agar syntax print dapat digunakan langsung untuk menampilkan property yang terdapat pada suatu class. Contoh Code : Berikut contoh override method __str__ pada class BilanganKompleks class BilanganKompleks: def __init__(self,a,b): self.real=a self.im=b def display(self): print (self.real,\"+\",self.im,\"i\") def __str__(self): return str(self.real)+\" + \"+str(self.im)+\" i \" data1=BilanganKompleks(4,6) data2=BilanganKompleks(2,5) print('Override Method') print(data1) print(data2) print('Method dalam Class') data1.display() data2.display() Output : Override Method 4+6i 2+5i Method dalam Class 4 + 6 i 2 + 5 i Penjumlahan dua buah bilangan kompleks berbeda dengan penjumlahan bilangan yang lain, karena bilangan kompleks ini terdiri dari dua bagian yaitu real dan imajiner. Untuk menjumlahkan bilangan kompleks. maka bagian real harus dijumlahkan pada bagian real juga dari bilangan lain, dan bagian imajiner harus ditambahkan dengan bagian imajiner. B. Code Contoh code berikut adalah pembuatan method baru di dalam class, yang berfungsi untuk menjumlahkan dua buah bilangan kompleks. class BilanganKompleks: def __init__(self,a,b): self.real=a self.im=b def display(self): print (self.real,'+',self.im,'i') def __str__(self): return str(self.real) + \" + \" + str(self.im) + \" i \" def addKompleks(self,obj): a=self.real+obj.real b=self.im+obj.im return BilanganKompleks(a,b) data1=BilanganKompleks(4,6) data2=BilanganKompleks(2,5) jumlah=data1.addKompleks(data2) data1.display() data2.display() print(jumlah) Output : 4 + 6 i 2 + 5 i 6 + 11 i Ketika ingin melakukan operasi penjumlahan dengan menggunakan operator '+', maka tidak dapat langsung dilakukan perintah sebagai berikut : data1=BilanganKompleks(4,6) data2=BilanganKompleks(2,5) jumlah=data1+data2 Operasi penjumlahan dengan operator '+' hanya dapat dilakukan dengan override fungsi __add__ yang sudah tersedia. Latihan Praktikum . Buatlah class Matrix dengan beberapa method seperti berikut : a. Constructor : untuk inisialisasi matriks, dengan parameter berupa jumlah baris dan kolom suatu matrix, dan elemen matriks merupakan inputan dari user (di dalam constructor) b. Override method str : untuk menampilkan matriks Gunakan formatting string jika diperlukan c. Override method add : untuk menjumlahkan dua buah matriks Pada method ini, haruslah dilakukan pengecekan, jika ukuran dua buah matriks yang akan dijumlahkan tidak sama, maka akan mengeluarkan warning bahwa ukuran tidak sama d. Override method mul : untuk mengalikan dua buah matriks Pada method ini, haruslah dilakukan pengecakan, jika jumlah kolom pada matriks pertama tidak sama dengan jumlah baris pada matriks kedua, maka akan mengeluarkan warning bahwa ukuran matriks tidak sesuai. #Ach Choirul Umamm #160411100075 #StrukdatD2 class matriks: #mat = {} def __init__(self, baris, kolom): self.b = [] self.baris = baris self.kolom = kolom for line in range(self.baris): k = [] for cols in range(self.kolom): k.append(0) self.b.append(k) inp = int(input(\"masukkan jumlah element : \")) for i in range(inp): bar = int(input(\"baris ke? : \")) kol = int(input(\"kolom ke? : \")) element = int(input(\"baris [{}][{}] : \".format(bar,kol))) self.b[bar][kol] = element def __str__(self): data = \"\" for i in range(len(self.b)): data += \"| \" for t in range(len(self.b[0])): data += str(self.b[i][t]) data += \" |\\n\" return data def __add__(self, tambah): angka = \"1234567890\" mat1 = [] kol1 = [] hasil = [] data = \"\" for t in range(len(tambah.b)): if str(tambah.b[t]) in angka: kol1.append(tambah.b[t]) else: kol1 = [] mat1.append(kol1) if len(self.b) == len(tambah.b): if len(tambah.b[0]) == len(self.b[0]): for u in range(len(self.b)): data += \"| \" kolo = [] for j in range(len(self.b[0])): has = tambah.b[u][j] + self.b[u][j] data += str(has) kolo.append(has) mat1.append(kolo) data += \" |\\n\" return \"hasil Penjumlahan\\n\" + data else: return \"penjumlahan tidak bisa dilakukan karena jumlah kolom tidak sama\" else: return \"penjumlahan tidak bisa dilakukan karena Jumlah baris tidak sama\" def __mul__(self, kali): angka = \"1234567890\" data = \"\" mat1 = [] kol1 = [] for t in range(len(kali.b)): if str(kali.b[t]) in angka: kol1.append(kali.b[t]) else: kol1 = [] mat1.append(kol1) if len(self.b[0]) == len(kali.b): mat_bar = [] for i in range(len(self.b)): data += \"| \" hasil = 0 mat_kol = [] for y in range(len(kali.b[0])): for t in range(len(self.b[0])): a = self.b[i][t] b = kali.b[t][y] perkalian = a*b hasil = hasil + perkalian data += str(hasil) mat_kol.append(hasil) mat_bar.append(mat_kol) data += \" |\\n\" return \"hasil dari perkalian = \\n\" + data else: return \"perkalian tidak bisa dilakukan karena jumlah kolom matrik1 tidak sama dengan jumlah kolom matrik2\" obj1 = matriks(2,2) print(obj1) obj2 = matriks(2,2) print(obj2) jumlah = obj1.__add__(obj2) print(jumlah) kali = obj1.__mul__(obj2) print(kali) Output : masukkan jumlah element : 2 baris ke? : 0 kolom ke? : 1 baris [0][1] : 2 baris ke? : 1 kolom ke? : 1 baris [1][1] : 2 | 02 | | 02 | masukkan jumlah element : 2 baris ke? : 0 kolom ke? : 1 baris [0][1] : 3 baris ke? : 1 kolom ke? : 0 baris [1][0] : 1 | 03 | | 10 | hasil Penjumlahan | 05 | | 12 | hasil dari perkalian = | 22 | | 22 | Buatlah class LinkedList, dengan beberapa method tambahan pada class LinkedList seperti berikut (untuk constructor LinkedList, dan class Node dapat dilihat pada materi perkuliahan): a. addRear : untuk menambahkan node di belakang linkedlist b. override method str : untuk menampilkan data linked list c. override method add : untuk menambahkan data dari dua buah linked list, dengan ketentuan, jumlah node pada linked list hasil penjumlahan sama dengan jumlah node terbanyak dari linked list yang akan dijumlahkan. #Ach. Choirul Umam #160411100075 class Node: def __init__(self,init_data): self.data = init_data self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self,new_data): self.data = new_data def setNext(self,next_data): self.next = next_data class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def addprev(self,item): temp = Node(item) temp.setNext(self.head) self.head = temp def addnext(self,item): temp = Node(item) current=self.head while current.getNext()!=None: current=current.getNext() current.setNext(temp) def size(self): current = self.head count=0 while current != None: count=count+1 current=current.getNext() return count def search(self,item): current=self.head found=False while current != None and not found: if current.getData() == item: found=True else: current=current.getNext() return found def tampil(self): current=self.head print(\"head->\",end=\" \") while current: print(current.getData(),end=\"->\") current=current.getNext() print(\"none\") def remove(self,item): current=self.head found=False previous= None while not found: if current.getData()==item: found=True else: previous = current current = current.getNext() if previous == None: self.head=current.getNext() else: previous.setNext(current.getNext()) def index(self, item): count = 0;current = self.head if item < 0: item = self.size()+item while current != None: if count==item: return current.getData() current = current.getNext() count += 1 print('Index melebihi jumlah data') #======================================================== #=================== LINKED LIST ========================= #======================================================== mylist=LinkedList() mylist2=LinkedList() mylist3=LinkedList() #======================================================= list1=\"y\" c=input(\"masukkan angka list ke-1:\") mylist.addprev(c) while list1==\"y\": a=input(\"masukkan angka list ke-1:\") mylist.addnext(a) list1=input(\"tekan y jika lagi dan tekan t jika tidak:\") #===================================================== list2=\"y\" d=input(\"masukkan angka list ke-2:\") mylist2.addprev(d) while list2==\"y\": b=input(\"masukkan angka list ke-2:\") mylist2.addnext(b) list2=input(\"tekan y jika lagi dan tekan t jika tidak:\") #==================================================== print(\"\\n==============================\") mylist.tampil() mylist2.tampil() print(\"==============================\") print(\"Hasil Dari Penjumlahan nya adalah :\") #==================================================== if mylist.size()>mylist2.size(): ha=mylist.size()-mylist2.size() for i in range(ha): mylist2.addnext(0) elif mylist.size()<mylist2.size(): ha=mylist2.size()-mylist.size() for i in range(ha): mylist.addnext(0) #==================================================== tambahawal=int(mylist.index(0))+int(mylist2.index(0)) mylist3.addprev(tambahawal) for i in range(1,mylist.size()): tambah=int(mylist.index(i))+int(mylist2.index(i)) mylist3.addnext(tambah) mylist3.tampil() print(\"==============================\") Output : masukkan angka list ke-1:1 masukkan angka list ke-1:1 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-1:3 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-1:3 tekan y jika lagi dan tekan t jika tidak:t masukkan angka list ke-2:1 masukkan angka list ke-2:1 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-2:2 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-2:2 tekan y jika lagi dan tekan t jika tidak:t ============================== head-> 1->1->3->3->none head-> 1->1->2->2->none ============================== Hasil Dari Penjumlahan nya adalah : head-> 2->2->5->5->none ==============================","title":"Materi 3 Classes"},{"location":"materi3/#classes","text":"","title":"Classes"},{"location":"materi3/#a-definisi","text":"class merupakan sebuah objek yang di dalam nya biasanya terdapat beberapa metode yang memang merupakan isi dari sebuah class ini. Class dan metode ini biasa di sebut sebagai (PBO) atau Pemrograman Berorientasi Obyek. Dan (PBO) ini memang fungsinya untuk memudahkan proses atau kegiatan programing. Berikut beberapa hal yang harus diketahui untuk pengenalan Pemrograman Berorientasi Obyek (PBO). 1. String dan List 2. Istilah dalam PBO 3. Constructur 4. Method 5. Overide Method","title":"A. Definisi"},{"location":"materi3/#string-dan-list","text":"Merupakan tipe data class yang sudah diketahui dan diginakan sebelumnya, adalah tipe data lists ataupun string. Suatu variabel yang berbentuk lists ataupun string , memiliki dua buah elemen yang terkandung di dalam variabel tersebut, yaitu nilai atau yang disebut dengan state / property , serta method atau fungsi, yang dapat digunakan untuk mengolah nilai pada variabel tersebut. Method atau fungsi yang melekat pada suatu variabel dapat diakses dengan menggunakan syntax. namaObyek.NamaMethod() Contoh : Berikut adalah contoh tipe data string dan lists, yang memiliki nilai sekaligus method. # String dataStr='Choirul' print(dataStr) dataStr=dataStr.upper() print(dataStr) Pada Contoh diatas terdapat variabel dataStr, berbentuk string. dimana property dari dataStr adalah 'Choirul', Contoh method yang digunakan adalah method upper() u p p e r (), yang berfungsi untuk merubah semua karakter pada dataStr d a t a S t r menjadi huruf kapital. Beberapa contoh method lain yang dapat digunakan adalah capitalize() c a p i t a l i z e (), lower() l o w e r (), find() f i n d (), dll # Lists dataLs=[12, 13, 14] print(dataLs) data.append(45) print(dataLs) Pada contoh code diatas, terdapat variabel dataLs d a t a L s yang berbentuk lists . Variabel ini memiliki tiga buah nilai, yaitu 12, 113, dan 14. Contoh method yang digunakan adalah append() a p p e n d (), yaitu menambah data pada variabel berbentuk lists . Contoh method method lain yang dimiliki tipe data lists yang bisa dimanfaatkan, misalkan pop() p o p (), insert() i n s e r t (), clear() c l e a r (), reverse() r e v e r s e (), dsb.","title":"String dan List"},{"location":"materi3/#istilah-dalam-pbo","text":"Kelebihan dari bahasa pemrogaraman berbasis object, adalah bahasa tersebut menyediakan beberapa fitur agar programmer dapat membuat class sendiri yang sesuai dengan kebutuhan. Beberapa istilah dasar yang terdapat pada pemrograman berbasis object ini antara lain : class , tipe data yang tidak hanya berisi data tetapi juga method object , suatu variabel dengan tipe data class state, property , bagian data dari suatu class yang berisi nilai, dapat berupa string, integer, float method , fungsi yang melekat pada class constructor , fungsi yang dijalankan oleh python ketika pertama kali suatu objek dibuat. Method constructor ini dibuat dengan cara mendefinisikan fungsi _ init _ (dua underscore ) self , merupakan suatu argumen atau parameter spesial agar nilai balik dari method dikembalikan ke objek itu sendiri. Argumen ini tidak perlu dipanggil (walaupun sudah didefinisikan)pada saat pemanggilan method instance , suatu objek yang telah dibuat override , mendefinisikan kembali fungsi-fungsi umum yang sudah ada, agar sesuai dengan kebutuhan programmer","title":"Istilah Dalam PBO"},{"location":"materi3/#constructor","text":"Syntax untuk membuat suatu class, adalah sebagai berikut : class namaClass: def _init_() : #constructor def namaMethod () : #Method Sedangkan untuk membuat suatu obyek dengan tipe data class tertentu (proses pembuatan instance ) adalah : namaObyek=namaClass() Constructor merupakan method yang otomatis dijalankan ketika suatu obyek dibuat. Syntax untuk pembuatan constructor ini adalah : def __init__() Contoh : class BilanganKompleks: def __init__(self,a,b): self.real=a self.im=b data=BilanganKompleks(4,6) print(data) untuk menampilkan property atau nilai yang dimiliki oleh suatu obyek, tidak dapat dilakukan dengan syntax print() seperti biasa. Terdapat dua cara agar objek yang sudah dibuat dapat ditampilkan di layar sesuai dengan yang diinginkan, yaitu: Membuat method baru untuk menampilkan data override method standar dari sebuah class","title":"Constructor"},{"location":"materi3/#method","text":"Method merupakan fungsi-fungsi yang terdapat di dalam suatu class. Contoh method yang akan dibuat adalah method yang berfungsi untuk menampilkan property atau state yang terdapat di dalam suatu obyek. Syntax pembuatan method adalah : def namaMethod(): Sedangkan untuk memanggil method suatu class adalah : namaObyek.namaMethod() Contoh : Berikut adalah contoh pembuatan method display() yang berfungsi untuk menampilkan property yang terdapat pada class Bilangan Kompleks. class BilanganKompleks: def __init__(self,a,b): # constructor self.real=a self.im=b def display(self): # method untuk menampilkan state print (self.real,'+',self.im,'i') data1=BilanganKompleks(4,6) data1.display() data2=BilanganKompleks(2,3) data2.display() Pada contoh code diatas, terdapat method tambahan pada class BilanganKompleks B i l a n g a n K o m p l e k s , yaitu method display() , yang berfungsi untuk menampilkan state atau property obyek dari class BilanganKompleks B i l a n g a n K o m p l e k s . Di dalam method tersebut, digunakan syntax print yang berfungsi untuk menampilkan suatu data. Perintah self.real adalah perintah untuk mengakses state atau property real r e a l , yang dimiliki oleh class BilanganKompleks B i l a n g a n K o m p l e k s , begitu juga dengan perintah self.im , digunakan untuk mengakses property im i m . Karena property real r e a l dan im i m bertipe data integer, maka syntax print() dapat dilakukan pada dua property tersebut","title":"Method"},{"location":"materi3/#5-override-method","text":"Override Method merupakan penambahan fungsi-fungsi pada syntax-syntax yang sudah ada. Seperti yang dijelaskan sebelumnya, untuk menampilkan property yang terdapat pada suatu obyek, tidak dapat dilakukan dengan menggunakan perintah print() . Cara pertama yang sudah dijelaskan adalah membuat method baru di dalam class, yang berfungsi untuk menampilkan property suatu class. Cara kedua adalah dengan cara override method fungsi yang sudah tersedia oleh bahasa pemrograman. Syntax yang akan di override adalah syntax print() . Yang perlu dilakukan agar suatu object dapat dipanggil dengan perintah print adalah object tersebut harus dirubah menjadi string. Untuk merubah suatu variabel menjadi string, maka suatu class dilengkapi dengan method __str__ . Hanya saja method ini tidak bisa berfungsi secara sempurna sesuai dengan apa yang diinginkan oleh programmer, yaitu agar syntax print dapat digunakan langsung untuk menampilkan property yang terdapat pada suatu class. Contoh Code : Berikut contoh override method __str__ pada class BilanganKompleks class BilanganKompleks: def __init__(self,a,b): self.real=a self.im=b def display(self): print (self.real,\"+\",self.im,\"i\") def __str__(self): return str(self.real)+\" + \"+str(self.im)+\" i \" data1=BilanganKompleks(4,6) data2=BilanganKompleks(2,5) print('Override Method') print(data1) print(data2) print('Method dalam Class') data1.display() data2.display() Output : Override Method 4+6i 2+5i Method dalam Class 4 + 6 i 2 + 5 i Penjumlahan dua buah bilangan kompleks berbeda dengan penjumlahan bilangan yang lain, karena bilangan kompleks ini terdiri dari dua bagian yaitu real dan imajiner. Untuk menjumlahkan bilangan kompleks. maka bagian real harus dijumlahkan pada bagian real juga dari bilangan lain, dan bagian imajiner harus ditambahkan dengan bagian imajiner.","title":"5. Override Method"},{"location":"materi3/#b-code","text":"Contoh code berikut adalah pembuatan method baru di dalam class, yang berfungsi untuk menjumlahkan dua buah bilangan kompleks. class BilanganKompleks: def __init__(self,a,b): self.real=a self.im=b def display(self): print (self.real,'+',self.im,'i') def __str__(self): return str(self.real) + \" + \" + str(self.im) + \" i \" def addKompleks(self,obj): a=self.real+obj.real b=self.im+obj.im return BilanganKompleks(a,b) data1=BilanganKompleks(4,6) data2=BilanganKompleks(2,5) jumlah=data1.addKompleks(data2) data1.display() data2.display() print(jumlah) Output : 4 + 6 i 2 + 5 i 6 + 11 i Ketika ingin melakukan operasi penjumlahan dengan menggunakan operator '+', maka tidak dapat langsung dilakukan perintah sebagai berikut : data1=BilanganKompleks(4,6) data2=BilanganKompleks(2,5) jumlah=data1+data2 Operasi penjumlahan dengan operator '+' hanya dapat dilakukan dengan override fungsi __add__ yang sudah tersedia. Latihan Praktikum . Buatlah class Matrix dengan beberapa method seperti berikut : a. Constructor : untuk inisialisasi matriks, dengan parameter berupa jumlah baris dan kolom suatu matrix, dan elemen matriks merupakan inputan dari user (di dalam constructor) b. Override method str : untuk menampilkan matriks Gunakan formatting string jika diperlukan c. Override method add : untuk menjumlahkan dua buah matriks Pada method ini, haruslah dilakukan pengecekan, jika ukuran dua buah matriks yang akan dijumlahkan tidak sama, maka akan mengeluarkan warning bahwa ukuran tidak sama d. Override method mul : untuk mengalikan dua buah matriks Pada method ini, haruslah dilakukan pengecakan, jika jumlah kolom pada matriks pertama tidak sama dengan jumlah baris pada matriks kedua, maka akan mengeluarkan warning bahwa ukuran matriks tidak sesuai. #Ach Choirul Umamm #160411100075 #StrukdatD2 class matriks: #mat = {} def __init__(self, baris, kolom): self.b = [] self.baris = baris self.kolom = kolom for line in range(self.baris): k = [] for cols in range(self.kolom): k.append(0) self.b.append(k) inp = int(input(\"masukkan jumlah element : \")) for i in range(inp): bar = int(input(\"baris ke? : \")) kol = int(input(\"kolom ke? : \")) element = int(input(\"baris [{}][{}] : \".format(bar,kol))) self.b[bar][kol] = element def __str__(self): data = \"\" for i in range(len(self.b)): data += \"| \" for t in range(len(self.b[0])): data += str(self.b[i][t]) data += \" |\\n\" return data def __add__(self, tambah): angka = \"1234567890\" mat1 = [] kol1 = [] hasil = [] data = \"\" for t in range(len(tambah.b)): if str(tambah.b[t]) in angka: kol1.append(tambah.b[t]) else: kol1 = [] mat1.append(kol1) if len(self.b) == len(tambah.b): if len(tambah.b[0]) == len(self.b[0]): for u in range(len(self.b)): data += \"| \" kolo = [] for j in range(len(self.b[0])): has = tambah.b[u][j] + self.b[u][j] data += str(has) kolo.append(has) mat1.append(kolo) data += \" |\\n\" return \"hasil Penjumlahan\\n\" + data else: return \"penjumlahan tidak bisa dilakukan karena jumlah kolom tidak sama\" else: return \"penjumlahan tidak bisa dilakukan karena Jumlah baris tidak sama\" def __mul__(self, kali): angka = \"1234567890\" data = \"\" mat1 = [] kol1 = [] for t in range(len(kali.b)): if str(kali.b[t]) in angka: kol1.append(kali.b[t]) else: kol1 = [] mat1.append(kol1) if len(self.b[0]) == len(kali.b): mat_bar = [] for i in range(len(self.b)): data += \"| \" hasil = 0 mat_kol = [] for y in range(len(kali.b[0])): for t in range(len(self.b[0])): a = self.b[i][t] b = kali.b[t][y] perkalian = a*b hasil = hasil + perkalian data += str(hasil) mat_kol.append(hasil) mat_bar.append(mat_kol) data += \" |\\n\" return \"hasil dari perkalian = \\n\" + data else: return \"perkalian tidak bisa dilakukan karena jumlah kolom matrik1 tidak sama dengan jumlah kolom matrik2\" obj1 = matriks(2,2) print(obj1) obj2 = matriks(2,2) print(obj2) jumlah = obj1.__add__(obj2) print(jumlah) kali = obj1.__mul__(obj2) print(kali) Output : masukkan jumlah element : 2 baris ke? : 0 kolom ke? : 1 baris [0][1] : 2 baris ke? : 1 kolom ke? : 1 baris [1][1] : 2 | 02 | | 02 | masukkan jumlah element : 2 baris ke? : 0 kolom ke? : 1 baris [0][1] : 3 baris ke? : 1 kolom ke? : 0 baris [1][0] : 1 | 03 | | 10 | hasil Penjumlahan | 05 | | 12 | hasil dari perkalian = | 22 | | 22 | Buatlah class LinkedList, dengan beberapa method tambahan pada class LinkedList seperti berikut (untuk constructor LinkedList, dan class Node dapat dilihat pada materi perkuliahan): a. addRear : untuk menambahkan node di belakang linkedlist b. override method str : untuk menampilkan data linked list c. override method add : untuk menambahkan data dari dua buah linked list, dengan ketentuan, jumlah node pada linked list hasil penjumlahan sama dengan jumlah node terbanyak dari linked list yang akan dijumlahkan. #Ach. Choirul Umam #160411100075 class Node: def __init__(self,init_data): self.data = init_data self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self,new_data): self.data = new_data def setNext(self,next_data): self.next = next_data class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def addprev(self,item): temp = Node(item) temp.setNext(self.head) self.head = temp def addnext(self,item): temp = Node(item) current=self.head while current.getNext()!=None: current=current.getNext() current.setNext(temp) def size(self): current = self.head count=0 while current != None: count=count+1 current=current.getNext() return count def search(self,item): current=self.head found=False while current != None and not found: if current.getData() == item: found=True else: current=current.getNext() return found def tampil(self): current=self.head print(\"head->\",end=\" \") while current: print(current.getData(),end=\"->\") current=current.getNext() print(\"none\") def remove(self,item): current=self.head found=False previous= None while not found: if current.getData()==item: found=True else: previous = current current = current.getNext() if previous == None: self.head=current.getNext() else: previous.setNext(current.getNext()) def index(self, item): count = 0;current = self.head if item < 0: item = self.size()+item while current != None: if count==item: return current.getData() current = current.getNext() count += 1 print('Index melebihi jumlah data') #======================================================== #=================== LINKED LIST ========================= #======================================================== mylist=LinkedList() mylist2=LinkedList() mylist3=LinkedList() #======================================================= list1=\"y\" c=input(\"masukkan angka list ke-1:\") mylist.addprev(c) while list1==\"y\": a=input(\"masukkan angka list ke-1:\") mylist.addnext(a) list1=input(\"tekan y jika lagi dan tekan t jika tidak:\") #===================================================== list2=\"y\" d=input(\"masukkan angka list ke-2:\") mylist2.addprev(d) while list2==\"y\": b=input(\"masukkan angka list ke-2:\") mylist2.addnext(b) list2=input(\"tekan y jika lagi dan tekan t jika tidak:\") #==================================================== print(\"\\n==============================\") mylist.tampil() mylist2.tampil() print(\"==============================\") print(\"Hasil Dari Penjumlahan nya adalah :\") #==================================================== if mylist.size()>mylist2.size(): ha=mylist.size()-mylist2.size() for i in range(ha): mylist2.addnext(0) elif mylist.size()<mylist2.size(): ha=mylist2.size()-mylist.size() for i in range(ha): mylist.addnext(0) #==================================================== tambahawal=int(mylist.index(0))+int(mylist2.index(0)) mylist3.addprev(tambahawal) for i in range(1,mylist.size()): tambah=int(mylist.index(i))+int(mylist2.index(i)) mylist3.addnext(tambah) mylist3.tampil() print(\"==============================\") Output : masukkan angka list ke-1:1 masukkan angka list ke-1:1 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-1:3 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-1:3 tekan y jika lagi dan tekan t jika tidak:t masukkan angka list ke-2:1 masukkan angka list ke-2:1 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-2:2 tekan y jika lagi dan tekan t jika tidak:y masukkan angka list ke-2:2 tekan y jika lagi dan tekan t jika tidak:t ============================== head-> 1->1->3->3->none head-> 1->1->2->2->none ============================== Hasil Dari Penjumlahan nya adalah : head-> 2->2->5->5->none ==============================","title":"B. Code"},{"location":"materi4/","text":"Linked List A. Definisi Linked List adalah suatu struktur data linier. Berbeda dengan array yang juga merupakan struktur data linier dan tipe data komposit, linked list dibentuk secara dinamik. Pada saat awal program dijalankan elemen linked list belum data. Elemen linked list (disebut node) dibentuk sambil jalan sesuai instruksi. Apabila setiap elemen array dapat diakses secara langsung dengan menggunakan indeks, sebuah node linked list diakses dengan menggunakan pointer yang mengacu (menunjuk) ke node tersebut. Node Untuk membuat struktur data linked list, terlebih dahulu dibuat node-node penyusun linked list tersebut. Node ini harus memiliki setidaknya dua informasi, yaitu informasi mengenai data atau nilai, dan informasi mengenai node berikutnya. Oleh karena itu node dibuat menjadi sebuah tipe data baru yang bertipe class , dengan dua informasi yaitu data dan next . Terdapat beberapa method penting pada class node ini, antara lain: constructor , yang akan dijalankan setiap instansiasi class getData , untuk mengetahui informasi data yang terdapat pada node tersebut getNext , untuk mengetahui informasi node berikutnya, jika tidak ada node berikutnya maka nilai balik berupa None setData , untuk merubah informasi data yang terdapat pada node tersebut setNext , untuk menentukan node berikutnya yang ditunjukan oleh informasi next dari node tersebut Contoh : Berikut adalah pembuatan class Node yang merupakan representasi dari sebuah node. Property atau state yang terdapat pada class Node ini : data : berisi nilai dari node next : berisi informasi berikutnya yang ditunjuk oleh node. Proses intansiasi, property next ini diset None yang merupakan representasi Nil atau Ground, berarti tidak ada node yang ditunjuk oleh node ini class Node: def __init__(self, init_data): self.data = init_data self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newdata): self.data = newdata def setNext(self, new_next): self.next = new_next a=Node(11) b=Node(110) print(a.getNext()) print(b.getNext()) a.setNext(b) print(a.getNext()) Di dalam Contoh diatas, terdapat obyek a dan obyek b dimana obyek tersebut memiliki tipe data class node. pada saat inisialisasi, kedua obyek bernilai 11 dan 110 , serta property next bernilai None . Pada baris ke-17, terdapat perintah a.setNext(b) , yang berarti property next dari obyek a akan menunjuk ke obyek b . Sehingga ketika dilakukan perintah print(a.getNext()) akan menunjukkan ke suatu class Node. Link List merupakan kumpulan dari node-node yang terhubung satu sama lain. Untuk mengakses node-node yang terdapat pada linked list. Contoh : Berikut adalah class untuk linked list, dimana pada class tersebut terdapat pointer yang menunjukkan node pertama dari suatu linked list ( head ). Terdapat dua buah method utama pada class LinkedList ini, antara lain: constructor , __init__ , yang merupakan method yang dijalankan pada saat pembuatan obyek. Karena obyek baru pertama kali dibuat, maka linked list masih kosong, sehingga pointer head masih bernilai None . Method isEmpty , untuk pengecekan apakah linked list memiliki node ataukah tidak. Jika pointer head masih menunjuk pada None , maka linked list masih tidak memiliki node, sehingga return value adalah True. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None mylist=LinkedList() print(mylist.head) mylist.isEmpty() Penambahan Data Pada Link list Penambahan data baru diletakkan pada awal link list yang terdapat pada pointer head. Algoritma : Tautkan node baru ini ke node awal dari linked list modifikasi head dari linked list agar menunjuk pada node baru Urutan tahapan ini tidak boleh dibalik , karena jika dibalik maka linked list yang awal tidak lagi dapat ditemukan. Contoh : Penambahan method add() pada link list. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp mylist=LinkedList() print(mylist.head) mylist.isEmpty() mylist.add(34) print(mylist.head) mylist.add(45) print(mylist.head) print(mylist.head.data) mylist.add(21) Setelah dilakukan penambahan node terakhir diatas, output mylist berisi =[21, 45, 34] Transversal Link List Cara mengetahui ukuran dari list, diperlukan tahapan traverse , yaitu menelusuri setiap node yang terdapat pada linked list. Pada proses penelusuran atau traversal dibutuhkan pointer bantuan. Pointer bantuan yang ditunjukkan pada Gambar diatas, adalah pointer curent yang bergerak dari node awal sampai dengan node akhir. Proses traversal ini dibutuhkan untuk beberapa hal, seperti untuk menghitung jumlah node yang terdapat pada Linked List, untuk mencari node pada linked list, untuk menampilkan seluruh node dari linked list, untuk menyisipkan node setelah atau sebelum node yang sudah terdapat pada linked list, dan untuk menghapus suatu node. Contoh : Implementasi yang akan dibuat adalah pembuatan method size(), untuk menghitung jumlah node. Algoritma : pointer bantuan curent berada pada node yang ditunjuk oleh head (yaitu node pertama) pointer curent bergerak, dengan perintah curent=curent.getNext() , sekaligus dilakukan increment variabel count, yang merepresentasikan jumlah node pergerakan atau traversal ini akan berakhir ketika pointer curent menunjuk pada None, yang merepresentasikan, tidak ada lagi node yang terdapat pada Linked list class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count mylist=LinkedList() mylist.add(45) mylist.add(34) mylist.add(70) print(mylist.size()) Pencarian Node pada Link List Untuk pencarian node di dalam linked list juga perlu dilakukan traverse linked list seperti sebelumnya, hanya saja setiap berada pada suatu node, maka dilakukan pencocokan apakah node tersebut adalah node yang dicari Contoh : penambahan method search() pada class LinkedList. Method search() ini hampir sama dengan method size , hanya saja jika ditambahkan apakah node yang ditunjukkan oleh pointer curent adalah node yang dicari, dengan perintah: if curent.getData() == item: #dimana item adalah node yang dicari class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def search(self,item): curent = self.head found = False while curent != None and not found: if curent.getData() == item: found = True else: curent = curent.getNext() return found mylist=LinkedList() mylist.add(45) mylist.add(34) mylist.add(70) mylist.add(84) mylist.size() mylist.search(34) Display data pada link list Proses traversal juga dapat digunakan untuk menampilkan data pada seluruh node yang terdapat pada Linked List. Contoh : Berikut method display() untuk menampilkan data dari seluruh node pada linked list. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def search(self,item): curent = self.head found = False while curent != None and not found: if curent.getData() == item: found = True else: curent = curent.getNext() return found def display(self): curent = self.head while curent != None: print(curent.getData()) curent = curent.getNext() mylist=LinkedList() mylist.add(45) mylist.add(34) mylist.add(70) mylist.add(84) mylist.display() Remove data pada link list Jika data yang dihapus berada di node awal dari linked list (yang ditunjukkan dengan nilai previous masih None , maka yang dilakukan pointer head langsung menunjuk pada node setelah node yang akan dihapus tersebut, Contoh : Berikut adalah penambahan method remove() untuk menghapus node yang diinginkan pada linked list. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def search(self,item): curent = self.head found = False while curent != None and not found: if curent.getData() == item: found = True else: curent = curent.getNext() return found def display(self): curent = self.head while curent != None: print(curent.getData()) curent = curent.getNext() def remove(self, item): curent = self.head previous = None found = False while not found: if curent.getData() == item: found = True else: previous = curent curent = curent.getNext() if previous == None: self.head = curent.getNext() else: previous.setNext(curent.getNext()) mylist=LinkedList() mylist.add(1) mylist.add(3) mylist.add(9) mylist.add(12) mylist.add(23) mylist.display() mylist.remove(3) mylist.display() Ordered List Proses pencarian pada linked list sebelumnya dilakukan dengan cara mencari node satu persatu sampai node terakhir. Proses pencarian ini akan menjadi lebih cepat jika data sudah dalam keadaan terurut, sehingga pencarian dapat dihentikan ketika ditemukan node dengan data lebih rendah atau lebih tinggi. Class Ordered List akan memudahkan pencarian suatu node, karena data yang terdapat pada class ini sudah dalam keadaan terurut. Method yang terdapat pada ordered list, sama halnya dengan class linkedlist, hanya saja terdapat perbedaan pada method untuk add data (karena node yang terbentuk harus dalam keadaan terurut), dan method search data. Contoh : Berikut method untuk class ordered list : class OrderedLinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def display(self): curent = self.head while curent != None: print(curent.getData()) curent = curent.getNext() def remove(self, item): curent = self.head previous = None found = False while not found: if curent.getData() == item: found = True else: previous = curent curent = curent.getNext() if previous == None: self.head = curent.getNext() else: previous.setNext(curent.getNext()) def search(self,item): curent = self.head found = False stop=False while curent != None and not found and not stop: if curent.getData() == item: found = True else: if curent.getData() > item: stop = True else: curent = curent.getNext() return found def add(self, item): curent=self.head previous = None stop = False while curent != None and not stop: if curent.getData() > item: stop = True else: previous = curent curent = curent.getNext() temp = Node(item) if previous == None: temp.setNext(self.head) self.head = temp else: # ditautkan antara previous dengan curent temp.setNext(curent) previous.setNext(temp) myList=OrderedLinkedList() myList.add(9) myList.add(14) myList.display() myList.add(100) myList.display() Latihan Praktikum 1. #Ach. Choirul Umam #160411100075 class Node: def __init__(self, init_data): self.data = init_data self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newdata): self.data = newdata def setNext(self, new_next): self.next = new_next class LinkedList: def __init__(self): self.head=None def isEmpty(self): return self.head==None def size(self): current = self.head count = 0 while current != None: count+=1 current=current.getNext() return count def addRear(self,item): temp=Node(item) if self.isEmpty()==True: self.head=temp else: current=self.head previous=None while current != None: previous=current current=current.getNext() previous.setNext(temp) def __str__(self): data=\"[\" current=self.head while current!=None: data+=str(current.data) current=current.getNext() if current!=None: data+=\",\" data+=\"]\" return(data) def insertPrevious(self,obj,item): temp=Node(item) current=self.head previous=None stop=False while current!=None and not stop: if current.getData()==obj: stop=True else: previous=current current=current.getNext() if stop==True: temp.setNext(current) previous.setNext(temp) def insertNext(self,obj,item): temp=Node(item) current=self.head previous=current stop=False while current!=None and not stop: if previous.getData()==obj: stop=True else: previous=current current=current.getNext() if stop==True: temp.setNext(current) previous.setNext(temp) myList1=LinkedList() myList1.addRear(5) myList1.addRear(84) myList1.addRear(12) myList1.addRear(77) print (myList1) myList1.insertPrevious(84,100) print(myList1) myList1.insertNext(12,122) print(myList1) class Sorting: def __init__(self,a): self.Data=a def bubbleSort(self,pilihan): t1=time.time()/10000000000 #print('Data yang akan diurutkan : ', self.Data) if pilihan==\"a\": for outIter in range(len(self.Data)-1,-1,-1): for i in range(outIter): if self.Data[i]>self.Data[i+1]: self.Data[i],self.Data[i+1]=self.Data[i+1],self.Data[i] elif pilihan==\"d\": for outIter in range(len(self.Data)-1,-1,-1): for i in range(outIter): if self.Data[i]<self.Data[i+1]: self.Data[i],self.Data[i+1]=self.Data[i+1],self.Data[i] return t1 def selectionSort(self,pilihan): t1=time.time()/10000000000 for outIter in range(len(self.Data)-1): minIndex=outIter if pilihan==\"a\": for i in range(outIter+1,len(self.Data)): if self.Data[i]<self.Data[minIndex]: minIndex=i self.Data[outIter],self.Data[minIndex]=self.Data[minIndex],self.Data[outIter] if pilihan==\"d\": for i in range(outIter+1,len(self.Data)): if self.Data[i]>self.Data[minIndex]: minIndex=i self.Data[outIter],self.Data[minIndex]=self.Data[minIndex],self.Data[outIter] return t1 def insertionSort(self,pilihan): t1=time.time()/10000000000 for outIter in range(1,len(self.Data)): key=self.Data[outIter] ind=outIter if pilihan==\"a\": while (ind>0 and self.Data[ind-1]>key): self.Data[ind]=self.Data[ind-1] ind=ind-1 self.Data[ind]=key if pilihan==\"d\": while (ind>0 and self.Data[ind-1]<key): self.Data[ind]=self.Data[ind-1] ind=ind-1 self.Data[ind]=key return t1 import time t1=time.time() import random a=randm.sample(range(0, 1000),500) dataSort=Sorting(a) t1=dataSort.bubbleSort(\"a\") print(dataSort.Data) print('waktu komputasi',t1,'detik')","title":"Materi 4 Linked List"},{"location":"materi4/#linked-list","text":"","title":"Linked List"},{"location":"materi4/#a-definisi","text":"Linked List adalah suatu struktur data linier. Berbeda dengan array yang juga merupakan struktur data linier dan tipe data komposit, linked list dibentuk secara dinamik. Pada saat awal program dijalankan elemen linked list belum data. Elemen linked list (disebut node) dibentuk sambil jalan sesuai instruksi. Apabila setiap elemen array dapat diakses secara langsung dengan menggunakan indeks, sebuah node linked list diakses dengan menggunakan pointer yang mengacu (menunjuk) ke node tersebut.","title":"A. Definisi"},{"location":"materi4/#node","text":"Untuk membuat struktur data linked list, terlebih dahulu dibuat node-node penyusun linked list tersebut. Node ini harus memiliki setidaknya dua informasi, yaitu informasi mengenai data atau nilai, dan informasi mengenai node berikutnya. Oleh karena itu node dibuat menjadi sebuah tipe data baru yang bertipe class , dengan dua informasi yaitu data dan next . Terdapat beberapa method penting pada class node ini, antara lain: constructor , yang akan dijalankan setiap instansiasi class getData , untuk mengetahui informasi data yang terdapat pada node tersebut getNext , untuk mengetahui informasi node berikutnya, jika tidak ada node berikutnya maka nilai balik berupa None setData , untuk merubah informasi data yang terdapat pada node tersebut setNext , untuk menentukan node berikutnya yang ditunjukan oleh informasi next dari node tersebut Contoh : Berikut adalah pembuatan class Node yang merupakan representasi dari sebuah node. Property atau state yang terdapat pada class Node ini : data : berisi nilai dari node next : berisi informasi berikutnya yang ditunjuk oleh node. Proses intansiasi, property next ini diset None yang merupakan representasi Nil atau Ground, berarti tidak ada node yang ditunjuk oleh node ini class Node: def __init__(self, init_data): self.data = init_data self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newdata): self.data = newdata def setNext(self, new_next): self.next = new_next a=Node(11) b=Node(110) print(a.getNext()) print(b.getNext()) a.setNext(b) print(a.getNext()) Di dalam Contoh diatas, terdapat obyek a dan obyek b dimana obyek tersebut memiliki tipe data class node. pada saat inisialisasi, kedua obyek bernilai 11 dan 110 , serta property next bernilai None . Pada baris ke-17, terdapat perintah a.setNext(b) , yang berarti property next dari obyek a akan menunjuk ke obyek b . Sehingga ketika dilakukan perintah print(a.getNext()) akan menunjukkan ke suatu class Node.","title":"Node"},{"location":"materi4/#link-list","text":"merupakan kumpulan dari node-node yang terhubung satu sama lain. Untuk mengakses node-node yang terdapat pada linked list. Contoh : Berikut adalah class untuk linked list, dimana pada class tersebut terdapat pointer yang menunjukkan node pertama dari suatu linked list ( head ). Terdapat dua buah method utama pada class LinkedList ini, antara lain: constructor , __init__ , yang merupakan method yang dijalankan pada saat pembuatan obyek. Karena obyek baru pertama kali dibuat, maka linked list masih kosong, sehingga pointer head masih bernilai None . Method isEmpty , untuk pengecekan apakah linked list memiliki node ataukah tidak. Jika pointer head masih menunjuk pada None , maka linked list masih tidak memiliki node, sehingga return value adalah True. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None mylist=LinkedList() print(mylist.head) mylist.isEmpty()","title":"Link List"},{"location":"materi4/#penambahan-data-pada-link-list","text":"Penambahan data baru diletakkan pada awal link list yang terdapat pada pointer head. Algoritma : Tautkan node baru ini ke node awal dari linked list modifikasi head dari linked list agar menunjuk pada node baru Urutan tahapan ini tidak boleh dibalik , karena jika dibalik maka linked list yang awal tidak lagi dapat ditemukan. Contoh : Penambahan method add() pada link list. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp mylist=LinkedList() print(mylist.head) mylist.isEmpty() mylist.add(34) print(mylist.head) mylist.add(45) print(mylist.head) print(mylist.head.data) mylist.add(21) Setelah dilakukan penambahan node terakhir diatas, output mylist berisi =[21, 45, 34]","title":"Penambahan Data Pada Link list"},{"location":"materi4/#transversal-link-list","text":"Cara mengetahui ukuran dari list, diperlukan tahapan traverse , yaitu menelusuri setiap node yang terdapat pada linked list. Pada proses penelusuran atau traversal dibutuhkan pointer bantuan. Pointer bantuan yang ditunjukkan pada Gambar diatas, adalah pointer curent yang bergerak dari node awal sampai dengan node akhir. Proses traversal ini dibutuhkan untuk beberapa hal, seperti untuk menghitung jumlah node yang terdapat pada Linked List, untuk mencari node pada linked list, untuk menampilkan seluruh node dari linked list, untuk menyisipkan node setelah atau sebelum node yang sudah terdapat pada linked list, dan untuk menghapus suatu node. Contoh : Implementasi yang akan dibuat adalah pembuatan method size(), untuk menghitung jumlah node. Algoritma : pointer bantuan curent berada pada node yang ditunjuk oleh head (yaitu node pertama) pointer curent bergerak, dengan perintah curent=curent.getNext() , sekaligus dilakukan increment variabel count, yang merepresentasikan jumlah node pergerakan atau traversal ini akan berakhir ketika pointer curent menunjuk pada None, yang merepresentasikan, tidak ada lagi node yang terdapat pada Linked list class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count mylist=LinkedList() mylist.add(45) mylist.add(34) mylist.add(70) print(mylist.size())","title":"Transversal Link List"},{"location":"materi4/#pencarian-node-pada-link-list","text":"Untuk pencarian node di dalam linked list juga perlu dilakukan traverse linked list seperti sebelumnya, hanya saja setiap berada pada suatu node, maka dilakukan pencocokan apakah node tersebut adalah node yang dicari Contoh : penambahan method search() pada class LinkedList. Method search() ini hampir sama dengan method size , hanya saja jika ditambahkan apakah node yang ditunjukkan oleh pointer curent adalah node yang dicari, dengan perintah: if curent.getData() == item: #dimana item adalah node yang dicari class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def search(self,item): curent = self.head found = False while curent != None and not found: if curent.getData() == item: found = True else: curent = curent.getNext() return found mylist=LinkedList() mylist.add(45) mylist.add(34) mylist.add(70) mylist.add(84) mylist.size() mylist.search(34)","title":"Pencarian Node pada Link List"},{"location":"materi4/#display-data-pada-link-list","text":"Proses traversal juga dapat digunakan untuk menampilkan data pada seluruh node yang terdapat pada Linked List. Contoh : Berikut method display() untuk menampilkan data dari seluruh node pada linked list. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def search(self,item): curent = self.head found = False while curent != None and not found: if curent.getData() == item: found = True else: curent = curent.getNext() return found def display(self): curent = self.head while curent != None: print(curent.getData()) curent = curent.getNext() mylist=LinkedList() mylist.add(45) mylist.add(34) mylist.add(70) mylist.add(84) mylist.display()","title":"Display data pada link list"},{"location":"materi4/#remove-data-pada-link-list","text":"Jika data yang dihapus berada di node awal dari linked list (yang ditunjukkan dengan nilai previous masih None , maka yang dilakukan pointer head langsung menunjuk pada node setelah node yang akan dihapus tersebut, Contoh : Berikut adalah penambahan method remove() untuk menghapus node yang diinginkan pada linked list. class LinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def add(self, item): temp = Node(item) temp.setNext(self.head) self.head = temp def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def search(self,item): curent = self.head found = False while curent != None and not found: if curent.getData() == item: found = True else: curent = curent.getNext() return found def display(self): curent = self.head while curent != None: print(curent.getData()) curent = curent.getNext() def remove(self, item): curent = self.head previous = None found = False while not found: if curent.getData() == item: found = True else: previous = curent curent = curent.getNext() if previous == None: self.head = curent.getNext() else: previous.setNext(curent.getNext()) mylist=LinkedList() mylist.add(1) mylist.add(3) mylist.add(9) mylist.add(12) mylist.add(23) mylist.display() mylist.remove(3) mylist.display()","title":"Remove data pada link list"},{"location":"materi4/#ordered-list","text":"Proses pencarian pada linked list sebelumnya dilakukan dengan cara mencari node satu persatu sampai node terakhir. Proses pencarian ini akan menjadi lebih cepat jika data sudah dalam keadaan terurut, sehingga pencarian dapat dihentikan ketika ditemukan node dengan data lebih rendah atau lebih tinggi. Class Ordered List akan memudahkan pencarian suatu node, karena data yang terdapat pada class ini sudah dalam keadaan terurut. Method yang terdapat pada ordered list, sama halnya dengan class linkedlist, hanya saja terdapat perbedaan pada method untuk add data (karena node yang terbentuk harus dalam keadaan terurut), dan method search data. Contoh : Berikut method untuk class ordered list : class OrderedLinkedList: def __init__(self): self.head = None def isEmpty(self): return self.head==None def size(self): curent = self.head count = 0 while curent != None: count = count + 1 curent = curent.getNext() return count def display(self): curent = self.head while curent != None: print(curent.getData()) curent = curent.getNext() def remove(self, item): curent = self.head previous = None found = False while not found: if curent.getData() == item: found = True else: previous = curent curent = curent.getNext() if previous == None: self.head = curent.getNext() else: previous.setNext(curent.getNext()) def search(self,item): curent = self.head found = False stop=False while curent != None and not found and not stop: if curent.getData() == item: found = True else: if curent.getData() > item: stop = True else: curent = curent.getNext() return found def add(self, item): curent=self.head previous = None stop = False while curent != None and not stop: if curent.getData() > item: stop = True else: previous = curent curent = curent.getNext() temp = Node(item) if previous == None: temp.setNext(self.head) self.head = temp else: # ditautkan antara previous dengan curent temp.setNext(curent) previous.setNext(temp) myList=OrderedLinkedList() myList.add(9) myList.add(14) myList.display() myList.add(100) myList.display()","title":"Ordered List"},{"location":"materi4/#latihan-praktikum","text":"1. #Ach. Choirul Umam #160411100075 class Node: def __init__(self, init_data): self.data = init_data self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newdata): self.data = newdata def setNext(self, new_next): self.next = new_next class LinkedList: def __init__(self): self.head=None def isEmpty(self): return self.head==None def size(self): current = self.head count = 0 while current != None: count+=1 current=current.getNext() return count def addRear(self,item): temp=Node(item) if self.isEmpty()==True: self.head=temp else: current=self.head previous=None while current != None: previous=current current=current.getNext() previous.setNext(temp) def __str__(self): data=\"[\" current=self.head while current!=None: data+=str(current.data) current=current.getNext() if current!=None: data+=\",\" data+=\"]\" return(data) def insertPrevious(self,obj,item): temp=Node(item) current=self.head previous=None stop=False while current!=None and not stop: if current.getData()==obj: stop=True else: previous=current current=current.getNext() if stop==True: temp.setNext(current) previous.setNext(temp) def insertNext(self,obj,item): temp=Node(item) current=self.head previous=current stop=False while current!=None and not stop: if previous.getData()==obj: stop=True else: previous=current current=current.getNext() if stop==True: temp.setNext(current) previous.setNext(temp) myList1=LinkedList() myList1.addRear(5) myList1.addRear(84) myList1.addRear(12) myList1.addRear(77) print (myList1) myList1.insertPrevious(84,100) print(myList1) myList1.insertNext(12,122) print(myList1) class Sorting: def __init__(self,a): self.Data=a def bubbleSort(self,pilihan): t1=time.time()/10000000000 #print('Data yang akan diurutkan : ', self.Data) if pilihan==\"a\": for outIter in range(len(self.Data)-1,-1,-1): for i in range(outIter): if self.Data[i]>self.Data[i+1]: self.Data[i],self.Data[i+1]=self.Data[i+1],self.Data[i] elif pilihan==\"d\": for outIter in range(len(self.Data)-1,-1,-1): for i in range(outIter): if self.Data[i]<self.Data[i+1]: self.Data[i],self.Data[i+1]=self.Data[i+1],self.Data[i] return t1 def selectionSort(self,pilihan): t1=time.time()/10000000000 for outIter in range(len(self.Data)-1): minIndex=outIter if pilihan==\"a\": for i in range(outIter+1,len(self.Data)): if self.Data[i]<self.Data[minIndex]: minIndex=i self.Data[outIter],self.Data[minIndex]=self.Data[minIndex],self.Data[outIter] if pilihan==\"d\": for i in range(outIter+1,len(self.Data)): if self.Data[i]>self.Data[minIndex]: minIndex=i self.Data[outIter],self.Data[minIndex]=self.Data[minIndex],self.Data[outIter] return t1 def insertionSort(self,pilihan): t1=time.time()/10000000000 for outIter in range(1,len(self.Data)): key=self.Data[outIter] ind=outIter if pilihan==\"a\": while (ind>0 and self.Data[ind-1]>key): self.Data[ind]=self.Data[ind-1] ind=ind-1 self.Data[ind]=key if pilihan==\"d\": while (ind>0 and self.Data[ind-1]<key): self.Data[ind]=self.Data[ind-1] ind=ind-1 self.Data[ind]=key return t1 import time t1=time.time() import random a=randm.sample(range(0, 1000),500) dataSort=Sorting(a) t1=dataSort.bubbleSort(\"a\") print(dataSort.Data) print('waktu komputasi',t1,'detik')","title":"Latihan Praktikum"},{"location":"materi5/","text":"Rekursif A.Definisi Fungsi rekursif dalam pemrograman merupakan fungsi yang memanggil dirinya sendiri. Fungsi rekursif sering saya bayangkan seperti perulangan. Karena tingkah lakunya yang mengulang-ulang setiap pemanggilan dirinya. Iteratif Iteratif merupakan penyelesaian permasalahan dengan perulangan, menggunakan syntax for atau while (pada Python). Contoh : Berikut adalah code untuk perhitungan faktorial suatu bilangan dengan menggunakan cara iteratif. Pada code ini, terdapat iterasi while, yang menghitung perkalian, mulai dari n n , sampai dengan 2. #Cara Iteratif def factorialIteratif(bilangan): if bilangan <=1: return(1) else: temp=bilangan hasil=1 while temp>1: hasil=hasil*temp temp=temp-1 return(hasil) print(factorialIteratif(4)) Rekursif merupakan suatu teknik pemrograman yang memecah permasalahan menjadi permasalahan dengan ukuran yang lebih kecil dan lebih kecil lagi, sehingga permasalahan dengan ukuran kecil tersebut dapat dengan mudah dipecahkan. Teknik ini dapat dilakukan dengan cara memanggil fungsi itu sendiri seperti definisi diatas. #Cara Rekursif def factorialRekursif(bilangan): if bilangan <=1: return(1) else: return(bilangan * factorialRekursif(bilangan-1)) data=factorialRekursif(4) print(data) Dari Fungsi tersubut terlihat beberapa perbedaan, dapat disimak bahwa teknik rekursif ini melibatkan pemaggilan fungsinya sendiri, dengan parameter yang berukuran lebih kecil. adapun aturan dalam teknik rekursif : Fungsi rekursif harus memiliki base case , base case inilah yang berfungsi untuk menghentikan pemanggilan terus menerus fungsi rekursif fungsi rekursif harus memiliki sintaks yang dapat merubah state dari permasalahan, sehingga semakin lama solusi permasalahan menuju base case yang sudah dibuat Fungsi rekursif harus memanggil dirinya sendiri B. Code Contoh : Berikut fungsi rekursif untuk konversi bilangan desimal menjadi bilangan base yang lain. def konversiDesimal(bilangan,base): charBilangan='0123456789ABCDEF' if bilangan<base: return(charBilangan[bilangan]) else: temp=bilangan//base ind=bilangan % base print(type(temp),temp,type(ind),ind) return(konversiDesimal(temp,base)+charBilangan[ind]) konversiDesimal(5,2) Visualisasi Rekursif Fractal Fractal merupakan cabang matematika dan memiliki banyak kesamaan dengan teknik rekursif. Fraktal memiliki bentuk dasar, dan bentuk dasar ini dikembangkan secara berulang terus menerus. Contoh : import turtle def draw_triangle(points, color, my_turtle): my_turtle.speed('slowest') my_turtle.fillcolor(color) my_turtle.up() my_turtle.goto(points[0][0],points[0][1]) my_turtle.down() my_turtle.begin_fill() my_turtle.goto(points[1][0], points[1][1]) my_turtle.goto(points[2][0], points[2][1]) my_turtle.goto(points[0][0], points[0][1]) my_turtle.end_fill() def get_mid(p1, p2): return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2) def sierpinski(points, degree, my_turtle): color_map = [\"blue\", \"red\" , \"green\", \"white\" , \"yellow\" ,\"violet\" , \"orange\"] draw_triangle(points, color_map[degree], my_turtle) if degree > 0: sierpinski([points[0],get_mid(points[0], points[1]), get_mid(points[0], points[2])], degree-1, my_turtle) sierpinski([points[1],get_mid(points[0], points[1]), get_mid(points[1], points[2])], degree-1, my_turtle) sierpinski([points[2],get_mid(points[2], points[1]), get_mid(points[0], points[2])], degree-1, my_turtle) def main(): my_turtle = turtle.Turtle() my_win = turtle.Screen() my_points = [[-100, -50], [0, 100], [100, -50]] sierpinski(my_points, 2, my_turtle) my_win.exitonclick() main() Latihan Praktikum 1. import turtle my_turtle = turtle.Turtle() my_win = turtle.Screen() def draw_square(my_turtle, line_len,a,banyak_level,b): if b<banyak_level+1: if a<4: if line_len > 0: my_turtle.forward(line_len/2) my_turtle.right(90) my_turtle.forward(line_len) my_turtle.right(90) my_turtle.forward(line_len/2) my_turtle.right(90) draw_square(my_turtle, line_len,a+1,banyak_level,b) else: draw_square(my_turtle, line_len/2,0,banyak_level,b+1) draw_square(my_turtle, 200,0,6,0) my_win.exitonclick()","title":"Materi 5 Rekursif"},{"location":"materi5/#rekursif","text":"","title":"Rekursif"},{"location":"materi5/#adefinisi","text":"Fungsi rekursif dalam pemrograman merupakan fungsi yang memanggil dirinya sendiri. Fungsi rekursif sering saya bayangkan seperti perulangan. Karena tingkah lakunya yang mengulang-ulang setiap pemanggilan dirinya.","title":"A.Definisi"},{"location":"materi5/#iteratif","text":"Iteratif merupakan penyelesaian permasalahan dengan perulangan, menggunakan syntax for atau while (pada Python). Contoh : Berikut adalah code untuk perhitungan faktorial suatu bilangan dengan menggunakan cara iteratif. Pada code ini, terdapat iterasi while, yang menghitung perkalian, mulai dari n n , sampai dengan 2. #Cara Iteratif def factorialIteratif(bilangan): if bilangan <=1: return(1) else: temp=bilangan hasil=1 while temp>1: hasil=hasil*temp temp=temp-1 return(hasil) print(factorialIteratif(4)) Rekursif merupakan suatu teknik pemrograman yang memecah permasalahan menjadi permasalahan dengan ukuran yang lebih kecil dan lebih kecil lagi, sehingga permasalahan dengan ukuran kecil tersebut dapat dengan mudah dipecahkan. Teknik ini dapat dilakukan dengan cara memanggil fungsi itu sendiri seperti definisi diatas. #Cara Rekursif def factorialRekursif(bilangan): if bilangan <=1: return(1) else: return(bilangan * factorialRekursif(bilangan-1)) data=factorialRekursif(4) print(data) Dari Fungsi tersubut terlihat beberapa perbedaan, dapat disimak bahwa teknik rekursif ini melibatkan pemaggilan fungsinya sendiri, dengan parameter yang berukuran lebih kecil. adapun aturan dalam teknik rekursif : Fungsi rekursif harus memiliki base case , base case inilah yang berfungsi untuk menghentikan pemanggilan terus menerus fungsi rekursif fungsi rekursif harus memiliki sintaks yang dapat merubah state dari permasalahan, sehingga semakin lama solusi permasalahan menuju base case yang sudah dibuat Fungsi rekursif harus memanggil dirinya sendiri","title":"Iteratif"},{"location":"materi5/#b-code","text":"Contoh : Berikut fungsi rekursif untuk konversi bilangan desimal menjadi bilangan base yang lain. def konversiDesimal(bilangan,base): charBilangan='0123456789ABCDEF' if bilangan<base: return(charBilangan[bilangan]) else: temp=bilangan//base ind=bilangan % base print(type(temp),temp,type(ind),ind) return(konversiDesimal(temp,base)+charBilangan[ind]) konversiDesimal(5,2)","title":"B. Code"},{"location":"materi5/#visualisasi-rekursif","text":"","title":"Visualisasi Rekursif"},{"location":"materi5/#fractal","text":"Fractal merupakan cabang matematika dan memiliki banyak kesamaan dengan teknik rekursif. Fraktal memiliki bentuk dasar, dan bentuk dasar ini dikembangkan secara berulang terus menerus. Contoh : import turtle def draw_triangle(points, color, my_turtle): my_turtle.speed('slowest') my_turtle.fillcolor(color) my_turtle.up() my_turtle.goto(points[0][0],points[0][1]) my_turtle.down() my_turtle.begin_fill() my_turtle.goto(points[1][0], points[1][1]) my_turtle.goto(points[2][0], points[2][1]) my_turtle.goto(points[0][0], points[0][1]) my_turtle.end_fill() def get_mid(p1, p2): return ((p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2) def sierpinski(points, degree, my_turtle): color_map = [\"blue\", \"red\" , \"green\", \"white\" , \"yellow\" ,\"violet\" , \"orange\"] draw_triangle(points, color_map[degree], my_turtle) if degree > 0: sierpinski([points[0],get_mid(points[0], points[1]), get_mid(points[0], points[2])], degree-1, my_turtle) sierpinski([points[1],get_mid(points[0], points[1]), get_mid(points[1], points[2])], degree-1, my_turtle) sierpinski([points[2],get_mid(points[2], points[1]), get_mid(points[0], points[2])], degree-1, my_turtle) def main(): my_turtle = turtle.Turtle() my_win = turtle.Screen() my_points = [[-100, -50], [0, 100], [100, -50]] sierpinski(my_points, 2, my_turtle) my_win.exitonclick() main()","title":"Fractal"},{"location":"materi5/#latihan-praktikum","text":"1. import turtle my_turtle = turtle.Turtle() my_win = turtle.Screen() def draw_square(my_turtle, line_len,a,banyak_level,b): if b<banyak_level+1: if a<4: if line_len > 0: my_turtle.forward(line_len/2) my_turtle.right(90) my_turtle.forward(line_len) my_turtle.right(90) my_turtle.forward(line_len/2) my_turtle.right(90) draw_square(my_turtle, line_len,a+1,banyak_level,b) else: draw_square(my_turtle, line_len/2,0,banyak_level,b+1) draw_square(my_turtle, 200,0,6,0) my_win.exitonclick()","title":"Latihan Praktikum"},{"location":"materi6/","text":"Searching 1. Sequential Searching A. Definisi Linear Searching atau sequential search adalah sebuah metode pencaran data dengan cara membandingkan nilai yang dicari dengan nilai dari setiap elemen list , mulai dari elemen pertama (indeks = 0) sampai nilai yang dicari ditemukan atau sampai elemen terakhir (indeks - n). Untuk lebih jelasnya perhatikan gambar animasi di bawah ini. \u200b Misalnya kita memiliki sebuah list, anggap saja list a. Di dalam list itu terdapat beberapa elemen yang terdiri dari beberapa angka acak. Katakanlah 8,5,7,9,2. Kita ingin mencari sebuah angka dari dalam list tersebut, misalnya angka 7. Dan juga kita bisa juga sekaligus mendapatkan informasi pada indeks ke-berapa letak angka tersebut berada, berapa kali iterasinya (proses perulangan saat mencari data tersebut). Unordered Sequential Search Pada unordered list sequential search , data berada pada keadaan acak, tidak terurut, sehingga pencarian harus dilakukan mulai dari indeks awal sampai indeks terakhir dari data, atau pencarian berhenti ketika data sudah ditemukan. Contoh : implementasi algoritma unordered list sequential search . def seqSearch(listData, data): ind = 0 found = False while ind < len(listData) and not found: if listData[ind] == data: found = True else: ind = ind+1 return found a=[12,5,9,8,1,10,26] seqSearch(a,1) Ordered equential List Pada ordered list sequential search, data sudah dalam keadaan terurut, hal ini tentunya dapat mengurangi waktu komputasi pencarian. Contoh : def orderedSeqSearch(listData, data): ind = 0 found = False stop = False position=[] while ind < len(listData) and not found and not stop: if listData[ind] == data: found = True position.append(ind) else: if listData[ind] > data: stop = True else: ind = ind+1 if found: return ind else: return ('Data tidak ada') a=[1,1,5,5,5,8,9,10,12,26] ind=orderedSeqSearch(a,5) print(ind) 2. Binary Seraching Binary Search merupakan metode pencarian data dengan membagi 2 atau pencarian dimulai dari indeks list bagian tengah, lalu membandingkannya. Jika bertemu dengan angka yang lebih kecil dari pada yang dicari, maka langsung dibuangnya, begitu seterusnya hingga nilai yang dicari (==) cocok. Cara kerja algoritma pencarian bagi-dua adalah dengan membagi elemen-elemen list menjadi dua bagian secara berulang. Jika nlai yang dicari (value) lebih kecil dari elemen tengah (alist[middle]), maka proses pencarian dilakukan pada bagian list sebelah kiri. Jika lebih besar, maka pencarian dilakukan pada bagian list sebelah kanan; dengan asumsi bahwa elemen-elemen list terurut secara menaik (ascending). Contoh : Berikut code untuk binary search dengan metode iteratif def binarySearch(listData, data): first = 0 last = len(listData) - 1 found = False while first <= last and not found: midpoint = (first + last) // 2 if listData[midpoint] == data: found = True else: if data < listData[midpoint]: last = midpoint - 1 else: first = midpoint + 1 return found a=[4,6,10,34,56,78,99] print(binarySearch(a,34)) Latihan Praktikum # nomer 1 def seqSearch(listData, data): iterasi = 0 hasil = [] found = 'Data tidak ada' for i in range(len(listData)): if listData[i] == data: hasil.append(i) found = hasil iterasi = iterasi+1 return found,iterasi a = [1,5,9,8,1,5,10,26,5,12] [hasil,jumlahIterasi] = seqSearch(a,5) print(\"===========SequentialSearch=====================\") print(\"data\",a) print('Posisi Data =',hasil) print('Jumlah Iterasi =',jumlahIterasi) # nomer 2 def orderedSeqSearch(listData, data): ind = 0 iterasi = 0 found = False stop = False position=[] while ind < len(listData) and not found and not stop: if listData[ind] == data and listData[ind+1] == data: position.append(ind) found = False iterasi += 1 ind = ind+1 elif listData[ind] == data and listData[ind+1] != data: position.append(ind) iterasi += 2 found = True else: if listData[ind] > data: iterasi += 1 stop = True else: iterasi += 1 ind = ind+1 if found: return position,iterasi else: return ('Data tidak ada',iterasi) a = [1,1,5,5,5,8,9,10,12,26] [hasil,iterasi] = orderedSeqSearch(a,5) print(\"==================orderedSeqSearch================\") print(\"data\",a) print('Posisi Data =',hasil) print('Jumlah Iterasi =',iterasi) # nomer 3 def binarySearch(listData, data): first = 0 iterasi = 0 last = len(listData) - 1 found = False hasil = [] while first <= last and not found: midpoint = (first + last) // 2 if listData[midpoint] == data and listData[midpoint-1] == data and listData[midpoint-2] != data: found = True hasil.append(midpoint) hasil.append(midpoint-1) iterasi += 2 elif listData[midpoint]==data and listData[midpoint-1] == data and listData[midpoint-2] ==data: found = True hasil.append(midpoint) hasil.append(midpoint-2) hasil.append(midpoint-1) iterasi += 4 elif listData[midpoint]==data and listData[midpoint-1] != data: found = True hasil.append(midpoint) iterasi += 1 else: if data < listData[midpoint]: last = midpoint - 1 iterasi += 1 else: first = midpoint + 1 iterasi += 1 if found : return hasil,iterasi else: return \"data tidak ada\",iterasi a = [1,1,5,5,5,8,9,10,12,26,30] [hasil,iterasi] = binarySearch(a,26) print(\"===========Binary Search=====================\") print(\"data\",a) print('Posisi Data =',hasil) print('Jumlah Iterasi =',iterasi) Output : ===========SequentialSearch===================== data [1, 5, 9, 8, 1, 5, 10, 26, 5, 12] Posisi Data = [1, 5, 8] Jumlah Iterasi = 3 ==================orderedSeqSearch================ data [1, 1, 5, 5, 5, 8, 9, 10, 12, 26] Posisi Data = [2, 3, 4] Jumlah Iterasi = 6 ===========Binary Search===================== data [1, 1, 5, 5, 5, 8, 9, 10, 12, 26, 30] Posisi Data = [9] Jumlah Iterasi = 3","title":"Materi 6 Searching"},{"location":"materi6/#searching","text":"","title":"Searching"},{"location":"materi6/#1-sequential-searching","text":"","title":"1. Sequential Searching"},{"location":"materi6/#a-definisi","text":"Linear Searching atau sequential search adalah sebuah metode pencaran data dengan cara membandingkan nilai yang dicari dengan nilai dari setiap elemen list , mulai dari elemen pertama (indeks = 0) sampai nilai yang dicari ditemukan atau sampai elemen terakhir (indeks - n). Untuk lebih jelasnya perhatikan gambar animasi di bawah ini. \u200b Misalnya kita memiliki sebuah list, anggap saja list a. Di dalam list itu terdapat beberapa elemen yang terdiri dari beberapa angka acak. Katakanlah 8,5,7,9,2. Kita ingin mencari sebuah angka dari dalam list tersebut, misalnya angka 7. Dan juga kita bisa juga sekaligus mendapatkan informasi pada indeks ke-berapa letak angka tersebut berada, berapa kali iterasinya (proses perulangan saat mencari data tersebut).","title":"A. Definisi"},{"location":"materi6/#unordered-sequential-search","text":"Pada unordered list sequential search , data berada pada keadaan acak, tidak terurut, sehingga pencarian harus dilakukan mulai dari indeks awal sampai indeks terakhir dari data, atau pencarian berhenti ketika data sudah ditemukan. Contoh : implementasi algoritma unordered list sequential search . def seqSearch(listData, data): ind = 0 found = False while ind < len(listData) and not found: if listData[ind] == data: found = True else: ind = ind+1 return found a=[12,5,9,8,1,10,26] seqSearch(a,1) Ordered equential List Pada ordered list sequential search, data sudah dalam keadaan terurut, hal ini tentunya dapat mengurangi waktu komputasi pencarian. Contoh : def orderedSeqSearch(listData, data): ind = 0 found = False stop = False position=[] while ind < len(listData) and not found and not stop: if listData[ind] == data: found = True position.append(ind) else: if listData[ind] > data: stop = True else: ind = ind+1 if found: return ind else: return ('Data tidak ada') a=[1,1,5,5,5,8,9,10,12,26] ind=orderedSeqSearch(a,5) print(ind)","title":"Unordered Sequential Search"},{"location":"materi6/#2-binary-seraching","text":"Binary Search merupakan metode pencarian data dengan membagi 2 atau pencarian dimulai dari indeks list bagian tengah, lalu membandingkannya. Jika bertemu dengan angka yang lebih kecil dari pada yang dicari, maka langsung dibuangnya, begitu seterusnya hingga nilai yang dicari (==) cocok. Cara kerja algoritma pencarian bagi-dua adalah dengan membagi elemen-elemen list menjadi dua bagian secara berulang. Jika nlai yang dicari (value) lebih kecil dari elemen tengah (alist[middle]), maka proses pencarian dilakukan pada bagian list sebelah kiri. Jika lebih besar, maka pencarian dilakukan pada bagian list sebelah kanan; dengan asumsi bahwa elemen-elemen list terurut secara menaik (ascending). Contoh : Berikut code untuk binary search dengan metode iteratif def binarySearch(listData, data): first = 0 last = len(listData) - 1 found = False while first <= last and not found: midpoint = (first + last) // 2 if listData[midpoint] == data: found = True else: if data < listData[midpoint]: last = midpoint - 1 else: first = midpoint + 1 return found a=[4,6,10,34,56,78,99] print(binarySearch(a,34))","title":"2. Binary Seraching"},{"location":"materi6/#latihan-praktikum","text":"# nomer 1 def seqSearch(listData, data): iterasi = 0 hasil = [] found = 'Data tidak ada' for i in range(len(listData)): if listData[i] == data: hasil.append(i) found = hasil iterasi = iterasi+1 return found,iterasi a = [1,5,9,8,1,5,10,26,5,12] [hasil,jumlahIterasi] = seqSearch(a,5) print(\"===========SequentialSearch=====================\") print(\"data\",a) print('Posisi Data =',hasil) print('Jumlah Iterasi =',jumlahIterasi) # nomer 2 def orderedSeqSearch(listData, data): ind = 0 iterasi = 0 found = False stop = False position=[] while ind < len(listData) and not found and not stop: if listData[ind] == data and listData[ind+1] == data: position.append(ind) found = False iterasi += 1 ind = ind+1 elif listData[ind] == data and listData[ind+1] != data: position.append(ind) iterasi += 2 found = True else: if listData[ind] > data: iterasi += 1 stop = True else: iterasi += 1 ind = ind+1 if found: return position,iterasi else: return ('Data tidak ada',iterasi) a = [1,1,5,5,5,8,9,10,12,26] [hasil,iterasi] = orderedSeqSearch(a,5) print(\"==================orderedSeqSearch================\") print(\"data\",a) print('Posisi Data =',hasil) print('Jumlah Iterasi =',iterasi) # nomer 3 def binarySearch(listData, data): first = 0 iterasi = 0 last = len(listData) - 1 found = False hasil = [] while first <= last and not found: midpoint = (first + last) // 2 if listData[midpoint] == data and listData[midpoint-1] == data and listData[midpoint-2] != data: found = True hasil.append(midpoint) hasil.append(midpoint-1) iterasi += 2 elif listData[midpoint]==data and listData[midpoint-1] == data and listData[midpoint-2] ==data: found = True hasil.append(midpoint) hasil.append(midpoint-2) hasil.append(midpoint-1) iterasi += 4 elif listData[midpoint]==data and listData[midpoint-1] != data: found = True hasil.append(midpoint) iterasi += 1 else: if data < listData[midpoint]: last = midpoint - 1 iterasi += 1 else: first = midpoint + 1 iterasi += 1 if found : return hasil,iterasi else: return \"data tidak ada\",iterasi a = [1,1,5,5,5,8,9,10,12,26,30] [hasil,iterasi] = binarySearch(a,26) print(\"===========Binary Search=====================\") print(\"data\",a) print('Posisi Data =',hasil) print('Jumlah Iterasi =',iterasi) Output : ===========SequentialSearch===================== data [1, 5, 9, 8, 1, 5, 10, 26, 5, 12] Posisi Data = [1, 5, 8] Jumlah Iterasi = 3 ==================orderedSeqSearch================ data [1, 1, 5, 5, 5, 8, 9, 10, 12, 26] Posisi Data = [2, 3, 4] Jumlah Iterasi = 6 ===========Binary Search===================== data [1, 1, 5, 5, 5, 8, 9, 10, 12, 26, 30] Posisi Data = [9] Jumlah Iterasi = 3","title":"Latihan Praktikum"},{"location":"materi7/","text":"Hashing A. Definisi Hashing adalah teknik atau metode memetakan data ke sebuah tempat dimana data sebenarnya dirubah dalam bentuk lain. semisal huruf a menjadi huruf e. Teknik ini biasanya digunakan untuk mengenkrispsi sebuah password didalam database seperti MySQL. Pada python, cara metode Hashing dengan membuat sebuah List yang akan diisi oleh data masukan. Data masukan diberi 2 buah nilai yaitu value sebagai data tersebut dan juga key sebagai alat untuk memasukan value ke List. Di dalam algoritma hashing ini terdapat beberapa istilah dasar sebagai berikut: Hash Table , yaitu sebuah tempat penyimpanan data, yang dibuat sedemikian rupa, sehingga dapat memudahkan pencarian. Tipe data list di python dapat digunakan untuk merepresentasikan hash table slot , yaitu posisi (indeks) yang terdapat pada hash table sebagai tempat penyimpanan setiap data. Karena slot berfungsi seperti halnya indeks, maka nilai slot adalah nilai integer mulai dari nol sampai dengan ukurang dari hash table, misalkan slot 0, slot 1, slot 2, .... , slot n n . Hash function , yaitu suatu fungsi yang memetakan antara data dengan slot di dalam hash table Algoritma Hashing sebagai berikut : Membuat tabel hash yang berisikan None Memasukan data yang ingin dimasukan Data masukan terdiri dari value dan keynya Lakukan pencarian modulus dari key yang dibagi panjang tabel hash Masukan value dari data tersebut ke dalam tabel hash sesuai indexnya. Ilustrasi Hashing : Fungsi Hash Hash function sangat berperan penting dalam algoritma hashing, dengan hash function, data didalam list disusun berdasarkan nilai hash, dan pencarian data dilakukan berdasarkan nilai hash dari hash function ini. Contoh : Berikut adalah fungsi-fungsi yang diperlukan untuk algoritma hashing , antara lain : hash function (gunakan remainder function, yaitu data dimodulus dengan 11), nilai balik merupakan nilai hash createHashTable, untuk membuat hash table, dengan inisialisasi semua slot berisi 'none' putData, yaitu menyusun data ke dalam hash table, berdasarkan nilai hash yang dihasilkan searchHash, argumen merupakan data yang dicari, dan nilai balik berupa True or False, yaitu apakah data ditemukan di dalam hash table Permasalahan yang terjadi pada hashing adalah apabila pada index yang terjadi banyak value, inilah yang disebut Collision. Cara mengatasinya ada tiga yang sudah saya pelajari, yaitu linear hashing, aquadratic hashing dan chainning. 1. linier hashing Linear Hashing Penyelesaian dengan linear yaitu melakukan penambahan 1 tiap index yang terjadi collision, misalnya, collison terjadi pada index 3, maka data selanjutnya yang berindex 3 akan ditambahkan ke index 4, jika index 4 sudah terdapat value atau isi maka data terdebut ditaruh di index 5. Contoh : print('=============== Program Hashing Data Numerik (Linear Probbing) ================ ') l = 'y' while l == 'y': table = int(input('Masukan panjang tabel Hash = ')) table = [None] * table print('Panjang Tabel Hash = %i'%(len(table))) def hash(x,table): return x % len(table) def insert(table,key,value): index = hash(key,table) if table[index] == None: table[index] = value else: collusion = index found = False ind = collusion + 1 if ind > len(table) - 1: ind = 0 while (ind <= len(table)-1) and not found: if table[ind] == None: found = True table[ind] = value ind = ind+1 #Jika ingin mencari data dengan hasil True dan False '''def searchHash(data,table): if data in table: print('Data ditemukan') else: print('Data tidak ditemukan')''' #Jika ingin mencari data dengan hasil index data yang dicari '''def searchHash(data,table): x = 0 found = False while x < len(table) and not found: if table[x] == data: found = True if found ==False: x+=1 if found == True: print('Data %s berada pada di index %s dari table'%(data,x)) else: print('Data %s tidak ditemukan'%data)''' #Jika ingin mencari data dengan cara hash dengan hasil True/False beserta indeks def searchHash(data,table): index = hash(data,table) if table[index] == data: print('True') print('Data %s berada pada index %s'(data,index)) return True else: col = index found = False ind = col + 1 if ind > len(table) - 1: ind = 0 kali = 1 while (ind <= len(table)-1) and not found: if table[ind] == data: found = True print('True') print('Data %s berada pada index %s'%(data,ind)) return True ind+=1 if ind> len(table)-1: ind = 0 if kali>len(table): found = True print('False') print('Data %s data tidak temukan'%data) return False kali+=1 masuk = 'y' while masuk == 'y': nginput = int(input('Masukan berapa kali ingin memasukan data ke Tabel Hash = ')) if nginput > len(table): print('Panjang data masukan lebih dari panjang Tabel Hash') print('Tolong masukan ulang') else: masuk = 'n' b = 1 while b<=nginput: masukan = int(input('Masukan angka yang ingin dimasukan ke Tabel Hash = ')) insert(table,masukan,masukan) b+=1 print(table) nginput = True while nginput: q = input('Apakah ingin mencari Data ? (y/n) ') if q == 'y': dicari = int(input('Masukan angka yang ingin dicari = ')) searchHash(dicari,table) elif q == 'n': nginput = False else: print('Masukan y atau n!') nginput = True k = 'y' while k =='y': l = input('Apakah ingin melanjutkan program ? (y/n) ') if l == 'y': k = 'n' elif l == 'n': print('Terima Kasih') k = 'n' else: print('Masukan y atau n!') k = 'y' 2. Aquadratic Hashing Penyelesaian dengan Quadratic/Aquadratic ini sama seperti linear akan tetapi penambahan tidak satu persatu, melainkan penambahnya di kuadratkan lalu dimodulus dengan panjang tabel hash. Misalnya yang terjadi collison pada index 3 dan panjang tabel hash 10 maka jika ditambahkan data yang berindex 3 maka data terbut ditaruh pada index ke 3 yang ditambah 1 kuadrat 2 jadi berindex 4 lalu dimodulus panjang tabel hash jadi index 4. Jika index 4 sudah terisi maka index ditambah 2 kuadrat 2 jadi 3+4 yaitu 7 dan dimodulus panjang tabel hash yaitu 10 menjadi index 7, begitu seterusnya hingga data dapat ditempakan ditempat kosong pada tabel hash. Contoh : print('============= Program Hashing Data Numerik (Qudratic Probbing) ================ ') l = 'y' while l == 'y': table = int(input('Masukan panjang tabel Hash = ')) table = [None] * table print('Panjang Tabel Hash = %i'%(len(table))) def hash(x,table): return x % len(table) def insert(table,key,value): index = hash(key,table) if table[index] == None: table[index] = value else: collusion = index found = False i = 1 while i > 0 and not found: ind = collusion + i**2 ind = ind % len(table) if table[ind] == None: found = True table[ind] = value i+=1 #Jika ingin mencari data dengan hasil True dan False '''def searchHash(data,table): if data in table: print('Data ditemukan') else: print('Data tidak ditemukan')''' #Jika ingin mencari data dengan hasil index data yang dicari def searchHash(x,table): posisi = 0 found = False while posisi < len(table) and not found: if table[posisi] == x: found = True if found==False: posisi += 1 print('Angka yang dicari adalah %s pada tabel %s'%(x,table)) print('Angka %s terdapat pada index = %s'%(x,posisi)) def searchHash(data,table): index = hash(data,table) if table[index] == data: print('True') print('Data %s berada pada index %s'(data,ind)) return True else: collusion = index found = False i = 1 kali = 1 while i > 0 and not found: ind = collusion + i**2 ind = ind % len(table) if table[ind] == data: found = True print('True') print('Data %s berada pada index %s'(data,ind)) i+=1 if kali > len(table): found = True print('False') print('Data %s tidak ditemukan'%data) return False kali+=1 masuk = 'y' while masuk == 'y': nginput = int(input('Masukan berapa kali ingin memasukan data ke Tabel Hash = ')) if nginput > len(table): print('Panjang data masukan lebih dari panjang Tabel Hash') print('Tolong masukan ulang') else: masuk = 'n' b = 1 while b<=nginput: masukan = int(input('Masukan angka yang ingin dimasukan ke Tabel Hash = ')) insert(table,masukan,masukan) b+=1 print(table) nginput = True while nginput: q = input('Apakah ingin mencari Data ? (y/n) ') if q == 'y': dicari = int(input('Masukan angka yang ingin dicari = ')) searchHash(dicari,table) elif q == 'n': nginput = False else: print('Masukan y atau n!') nginput = True k = 'y' while k =='y': l = input('Apakah ingin melanjutkan program ? (y/n) ') if l == 'y': k = 'n' elif l == 'n': print('Terima Kasih') k = 'n' else: print('Masukan y atau n!') k = 'y' 3.Chaining Penyelesaian dengan cara Chainning yaitu membuat list didalam tabel hash sehingga data yang berindex sama tidak terjadi collison karena data tersebut ditumpuk ke dalam sebuah list yang telah dibuat. Contoh : print('============= Program Hashing Data Numerik (Chaining Probbing) ================ ') l = 'y' while l == 'y': table = int(input('Masukan panjang tabel Hash = ')) table = [ [] for _ in range(table) ] def hash(x,table): return x % len(table) def insert(table,key,value): table[hash(key,table)].append(value) #Jika ingin mencari data dengan hasil True dan False '''def searchHash(data,table): found = False i = 0 j = 0 while i < len(table) and not found: if data in table[i]: print('Data ditemukan') found = True i+=1 if found == False: print('Data tidak ditemukan')''' #Jika ingin mencari data dengan hasil index data yang dicari '''def searchHash(data,table): found = False i = 0 while i < len(table) and not found: j = 0 while j < len(table[i]) and not found: if data == table[i][j]: found = True if found==False: j+=1 if found==False: i+=1 if found == True: print('Data %s berada pada list ke-%s index ke-%s'%(data,(i+1),j)) else: print('Data %s tidak ditemukan'%data)''' def searchHash(data,table): index = hash(data,table) if data in table[index]: print('True') jml = len(table[index]) for i in range(jml): if data == table[index[i]]: break print('Data %s berada di dalam list %s index %s'%(data,index,i)) else: print('Data %s tidak ditemukan'%data) nginput = int(input('Masukan berapa kali ingin memasukan data ke Tabel Hash = ')) b = 1 while b<=nginput: masukan = int(input('Masukan angka yang ingin dimasukan ke Tabel Hash = ')) insert(table,masukan,masukan) b+=1 print(table) nginput = True while nginput: q = input('Apakah ingin mencari Data ? (y/n) ') if q == 'y': dicari = int(input('Masukan angka yang ingin dicari = ')) searchHash(dicari,table) elif q == 'n': nginput = False else: print('Masukan y atau n!') nginput = True k = 'y' while k =='y': l = input('Apakah ingin melanjutkan program ? (y/n) ') if l == 'y': k = 'n' elif l == 'n': print('Terima Kasih') k = 'n' else: print('Masukan y atau n!') k = 'y' Latihan Praktikum table=[[]for i in range(10)] def remainder(data, num): return (data%num) slot = remainder(55,10) print(slot) def hash(x): a = [] for i in range (x): a.append(\"none\") return x % 10 hashTable = hash(11) print(hashTable) def insert(table,key,value): index=hash(key) table[index].append(value) def search(table,value): index=hash(value) if len(table[index])-1 > 0: index2=table[index] i=0 found=False while i <=len(table[index]) and not found: if index2[i]== value: found=True print(value,\"ada di list ke\",index,\"index ke-\",i) else: i=i+1 else: i=0 print( value, \"ada di list ke\", index, \"index ke-\", i) insert(table,2,2) insert(table,3,3) insert(table,12,12) insert(table,13,13) insert(table,23,23) insert(table,10,10) insert(table,4,22) insert(table,3,33) print(table) search(table,3) search(table,2) search(table,12) search(table,13) search(table,23) search(table,10) Output : 5 1 [[10], [], [2, 12], [3, 13, 23, 33], [22], [], [], [], [], []] 3 ada di list ke 3 index ke- 0 2 ada di list ke 2 index ke- 0 12 ada di list ke 2 index ke- 1 13 ada di list ke 3 index ke- 1 23 ada di list ke 3 index ke- 2 10 ada di list ke 0 index ke- 0","title":"Materi 7 Hashing"},{"location":"materi7/#hashing","text":"","title":"Hashing"},{"location":"materi7/#a-definisi","text":"Hashing adalah teknik atau metode memetakan data ke sebuah tempat dimana data sebenarnya dirubah dalam bentuk lain. semisal huruf a menjadi huruf e. Teknik ini biasanya digunakan untuk mengenkrispsi sebuah password didalam database seperti MySQL. Pada python, cara metode Hashing dengan membuat sebuah List yang akan diisi oleh data masukan. Data masukan diberi 2 buah nilai yaitu value sebagai data tersebut dan juga key sebagai alat untuk memasukan value ke List. Di dalam algoritma hashing ini terdapat beberapa istilah dasar sebagai berikut: Hash Table , yaitu sebuah tempat penyimpanan data, yang dibuat sedemikian rupa, sehingga dapat memudahkan pencarian. Tipe data list di python dapat digunakan untuk merepresentasikan hash table slot , yaitu posisi (indeks) yang terdapat pada hash table sebagai tempat penyimpanan setiap data. Karena slot berfungsi seperti halnya indeks, maka nilai slot adalah nilai integer mulai dari nol sampai dengan ukurang dari hash table, misalkan slot 0, slot 1, slot 2, .... , slot n n . Hash function , yaitu suatu fungsi yang memetakan antara data dengan slot di dalam hash table Algoritma Hashing sebagai berikut : Membuat tabel hash yang berisikan None Memasukan data yang ingin dimasukan Data masukan terdiri dari value dan keynya Lakukan pencarian modulus dari key yang dibagi panjang tabel hash Masukan value dari data tersebut ke dalam tabel hash sesuai indexnya. Ilustrasi Hashing :","title":"A. Definisi"},{"location":"materi7/#fungsi-hash","text":"Hash function sangat berperan penting dalam algoritma hashing, dengan hash function, data didalam list disusun berdasarkan nilai hash, dan pencarian data dilakukan berdasarkan nilai hash dari hash function ini. Contoh : Berikut adalah fungsi-fungsi yang diperlukan untuk algoritma hashing , antara lain : hash function (gunakan remainder function, yaitu data dimodulus dengan 11), nilai balik merupakan nilai hash createHashTable, untuk membuat hash table, dengan inisialisasi semua slot berisi 'none' putData, yaitu menyusun data ke dalam hash table, berdasarkan nilai hash yang dihasilkan searchHash, argumen merupakan data yang dicari, dan nilai balik berupa True or False, yaitu apakah data ditemukan di dalam hash table Permasalahan yang terjadi pada hashing adalah apabila pada index yang terjadi banyak value, inilah yang disebut Collision. Cara mengatasinya ada tiga yang sudah saya pelajari, yaitu linear hashing, aquadratic hashing dan chainning. 1. linier hashing Linear Hashing Penyelesaian dengan linear yaitu melakukan penambahan 1 tiap index yang terjadi collision, misalnya, collison terjadi pada index 3, maka data selanjutnya yang berindex 3 akan ditambahkan ke index 4, jika index 4 sudah terdapat value atau isi maka data terdebut ditaruh di index 5. Contoh : print('=============== Program Hashing Data Numerik (Linear Probbing) ================ ') l = 'y' while l == 'y': table = int(input('Masukan panjang tabel Hash = ')) table = [None] * table print('Panjang Tabel Hash = %i'%(len(table))) def hash(x,table): return x % len(table) def insert(table,key,value): index = hash(key,table) if table[index] == None: table[index] = value else: collusion = index found = False ind = collusion + 1 if ind > len(table) - 1: ind = 0 while (ind <= len(table)-1) and not found: if table[ind] == None: found = True table[ind] = value ind = ind+1 #Jika ingin mencari data dengan hasil True dan False '''def searchHash(data,table): if data in table: print('Data ditemukan') else: print('Data tidak ditemukan')''' #Jika ingin mencari data dengan hasil index data yang dicari '''def searchHash(data,table): x = 0 found = False while x < len(table) and not found: if table[x] == data: found = True if found ==False: x+=1 if found == True: print('Data %s berada pada di index %s dari table'%(data,x)) else: print('Data %s tidak ditemukan'%data)''' #Jika ingin mencari data dengan cara hash dengan hasil True/False beserta indeks def searchHash(data,table): index = hash(data,table) if table[index] == data: print('True') print('Data %s berada pada index %s'(data,index)) return True else: col = index found = False ind = col + 1 if ind > len(table) - 1: ind = 0 kali = 1 while (ind <= len(table)-1) and not found: if table[ind] == data: found = True print('True') print('Data %s berada pada index %s'%(data,ind)) return True ind+=1 if ind> len(table)-1: ind = 0 if kali>len(table): found = True print('False') print('Data %s data tidak temukan'%data) return False kali+=1 masuk = 'y' while masuk == 'y': nginput = int(input('Masukan berapa kali ingin memasukan data ke Tabel Hash = ')) if nginput > len(table): print('Panjang data masukan lebih dari panjang Tabel Hash') print('Tolong masukan ulang') else: masuk = 'n' b = 1 while b<=nginput: masukan = int(input('Masukan angka yang ingin dimasukan ke Tabel Hash = ')) insert(table,masukan,masukan) b+=1 print(table) nginput = True while nginput: q = input('Apakah ingin mencari Data ? (y/n) ') if q == 'y': dicari = int(input('Masukan angka yang ingin dicari = ')) searchHash(dicari,table) elif q == 'n': nginput = False else: print('Masukan y atau n!') nginput = True k = 'y' while k =='y': l = input('Apakah ingin melanjutkan program ? (y/n) ') if l == 'y': k = 'n' elif l == 'n': print('Terima Kasih') k = 'n' else: print('Masukan y atau n!') k = 'y' 2. Aquadratic Hashing Penyelesaian dengan Quadratic/Aquadratic ini sama seperti linear akan tetapi penambahan tidak satu persatu, melainkan penambahnya di kuadratkan lalu dimodulus dengan panjang tabel hash. Misalnya yang terjadi collison pada index 3 dan panjang tabel hash 10 maka jika ditambahkan data yang berindex 3 maka data terbut ditaruh pada index ke 3 yang ditambah 1 kuadrat 2 jadi berindex 4 lalu dimodulus panjang tabel hash jadi index 4. Jika index 4 sudah terisi maka index ditambah 2 kuadrat 2 jadi 3+4 yaitu 7 dan dimodulus panjang tabel hash yaitu 10 menjadi index 7, begitu seterusnya hingga data dapat ditempakan ditempat kosong pada tabel hash. Contoh : print('============= Program Hashing Data Numerik (Qudratic Probbing) ================ ') l = 'y' while l == 'y': table = int(input('Masukan panjang tabel Hash = ')) table = [None] * table print('Panjang Tabel Hash = %i'%(len(table))) def hash(x,table): return x % len(table) def insert(table,key,value): index = hash(key,table) if table[index] == None: table[index] = value else: collusion = index found = False i = 1 while i > 0 and not found: ind = collusion + i**2 ind = ind % len(table) if table[ind] == None: found = True table[ind] = value i+=1 #Jika ingin mencari data dengan hasil True dan False '''def searchHash(data,table): if data in table: print('Data ditemukan') else: print('Data tidak ditemukan')''' #Jika ingin mencari data dengan hasil index data yang dicari def searchHash(x,table): posisi = 0 found = False while posisi < len(table) and not found: if table[posisi] == x: found = True if found==False: posisi += 1 print('Angka yang dicari adalah %s pada tabel %s'%(x,table)) print('Angka %s terdapat pada index = %s'%(x,posisi)) def searchHash(data,table): index = hash(data,table) if table[index] == data: print('True') print('Data %s berada pada index %s'(data,ind)) return True else: collusion = index found = False i = 1 kali = 1 while i > 0 and not found: ind = collusion + i**2 ind = ind % len(table) if table[ind] == data: found = True print('True') print('Data %s berada pada index %s'(data,ind)) i+=1 if kali > len(table): found = True print('False') print('Data %s tidak ditemukan'%data) return False kali+=1 masuk = 'y' while masuk == 'y': nginput = int(input('Masukan berapa kali ingin memasukan data ke Tabel Hash = ')) if nginput > len(table): print('Panjang data masukan lebih dari panjang Tabel Hash') print('Tolong masukan ulang') else: masuk = 'n' b = 1 while b<=nginput: masukan = int(input('Masukan angka yang ingin dimasukan ke Tabel Hash = ')) insert(table,masukan,masukan) b+=1 print(table) nginput = True while nginput: q = input('Apakah ingin mencari Data ? (y/n) ') if q == 'y': dicari = int(input('Masukan angka yang ingin dicari = ')) searchHash(dicari,table) elif q == 'n': nginput = False else: print('Masukan y atau n!') nginput = True k = 'y' while k =='y': l = input('Apakah ingin melanjutkan program ? (y/n) ') if l == 'y': k = 'n' elif l == 'n': print('Terima Kasih') k = 'n' else: print('Masukan y atau n!') k = 'y' 3.Chaining Penyelesaian dengan cara Chainning yaitu membuat list didalam tabel hash sehingga data yang berindex sama tidak terjadi collison karena data tersebut ditumpuk ke dalam sebuah list yang telah dibuat. Contoh : print('============= Program Hashing Data Numerik (Chaining Probbing) ================ ') l = 'y' while l == 'y': table = int(input('Masukan panjang tabel Hash = ')) table = [ [] for _ in range(table) ] def hash(x,table): return x % len(table) def insert(table,key,value): table[hash(key,table)].append(value) #Jika ingin mencari data dengan hasil True dan False '''def searchHash(data,table): found = False i = 0 j = 0 while i < len(table) and not found: if data in table[i]: print('Data ditemukan') found = True i+=1 if found == False: print('Data tidak ditemukan')''' #Jika ingin mencari data dengan hasil index data yang dicari '''def searchHash(data,table): found = False i = 0 while i < len(table) and not found: j = 0 while j < len(table[i]) and not found: if data == table[i][j]: found = True if found==False: j+=1 if found==False: i+=1 if found == True: print('Data %s berada pada list ke-%s index ke-%s'%(data,(i+1),j)) else: print('Data %s tidak ditemukan'%data)''' def searchHash(data,table): index = hash(data,table) if data in table[index]: print('True') jml = len(table[index]) for i in range(jml): if data == table[index[i]]: break print('Data %s berada di dalam list %s index %s'%(data,index,i)) else: print('Data %s tidak ditemukan'%data) nginput = int(input('Masukan berapa kali ingin memasukan data ke Tabel Hash = ')) b = 1 while b<=nginput: masukan = int(input('Masukan angka yang ingin dimasukan ke Tabel Hash = ')) insert(table,masukan,masukan) b+=1 print(table) nginput = True while nginput: q = input('Apakah ingin mencari Data ? (y/n) ') if q == 'y': dicari = int(input('Masukan angka yang ingin dicari = ')) searchHash(dicari,table) elif q == 'n': nginput = False else: print('Masukan y atau n!') nginput = True k = 'y' while k =='y': l = input('Apakah ingin melanjutkan program ? (y/n) ') if l == 'y': k = 'n' elif l == 'n': print('Terima Kasih') k = 'n' else: print('Masukan y atau n!') k = 'y' Latihan Praktikum table=[[]for i in range(10)] def remainder(data, num): return (data%num) slot = remainder(55,10) print(slot) def hash(x): a = [] for i in range (x): a.append(\"none\") return x % 10 hashTable = hash(11) print(hashTable) def insert(table,key,value): index=hash(key) table[index].append(value) def search(table,value): index=hash(value) if len(table[index])-1 > 0: index2=table[index] i=0 found=False while i <=len(table[index]) and not found: if index2[i]== value: found=True print(value,\"ada di list ke\",index,\"index ke-\",i) else: i=i+1 else: i=0 print( value, \"ada di list ke\", index, \"index ke-\", i) insert(table,2,2) insert(table,3,3) insert(table,12,12) insert(table,13,13) insert(table,23,23) insert(table,10,10) insert(table,4,22) insert(table,3,33) print(table) search(table,3) search(table,2) search(table,12) search(table,13) search(table,23) search(table,10) Output : 5 1 [[10], [], [2, 12], [3, 13, 23, 33], [22], [], [], [], [], []] 3 ada di list ke 3 index ke- 0 2 ada di list ke 2 index ke- 0 12 ada di list ke 2 index ke- 1 13 ada di list ke 3 index ke- 1 23 ada di list ke 3 index ke- 2 10 ada di list ke 0 index ke- 0","title":"Fungsi Hash"},{"location":"materi8/","text":"Tree Pada materi sebelumnya kita telah belajar mengenai menyimpanan data secara linear, seperti hasing, stack, queue dan linked list. Pada mater kali ini kita akan mempelajari Tree yang memiliki cara penyimpanan data non-linear melainkan secara hierarki. Bagaimana maksudnya? Untuk mempermudahnya kita bayangkan saja susunan keluarga yang kita miliki. Jika diperhatikan dalam susunan tersebut kita akan menemukan siapa kakek kita, orang tua kita, saudara orang tua atau paman kita, sepepupu kita, saudara kita, atau bahkan cucu kita bukan? Begitulah kira - kira penggambarannya dari pengertian Tree penyimpanan data secara hierarki yang tersusun secara urut dari kakek hingga cucu. Berikut atribut - atribut yang terdapat dalam Tree : Node , merupakan bagian dari tree yang menyimpan informasi atau juga disebut sebagai key Edge yang menghubungkan antara node yang satu dengan yang lain. Hanya ada satu edge yang masuk ke dalam node, dan satu atau lebih edge yang keluar dari suatu node Root node yang terletak di paling atas, tidak ada edge yang masuk ke dalam node root ini, tapi root mempunyai satu atau lebih dari satu edge yang keluar. path merupakan urutan node dari root sampai tujuan, misalkan computer --> D: --> Mata Kuliah --> Struktur Data children , merupakan node-node yang memiliki edge yang masuk dari node yang sama. Misalkan program files, users, dan windows merupakan children, krn memiliki edge masuk yang sama-sama berasal dari node C: Parent node yang memiliki edge yang keluar dari node tersebut, misalkan node C: adalah parent dari program files, users, dan windows Siblings adalah node-node yang berasal dari parent yang sama subtree kumpulan dari node dan edge yang terdiri dari parent dan semua node setelah parent leaf node , node yang tidak memiliki edge yang keluar, node yang tidak memiliki children level , tingkatan dari node. Root merupakan level ke-0, semakin kebawah maka level dari node tersebut semakin besar, misalkan struktur data berada di level ke-3 height merupakan tinggi tree, nilai dari height ini adalah level maksimum dari tree 1. Binary Tree Binary tree merupakan tree dimana setiap parent hanya memiliki dua buah atau satu node children saja. class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None myTree=BinaryTree(10) print(myTree.leftChild) Contoh : class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t Di mehod insertLeft perlu dilakukan pengecekan terlebih dahulu, apakah child kiri dari node yang akan disisipi subtree baru masih kosong, jika iya maka subtree tersebut dimasukkan pada leftChild. Dapat Menggunakan Perintah: self.leftChild=BinaryTree(new_node) Namun, jika setelah dilakukan pengecekan pada binary tree, ternyata leftChild tersebut tidak kosong, Misalkan terdapat tree 'u', dimana tree 'u' tersebut, memiliki leftchild, yaitu 'm'. Jika ingin dilakukan penyisipan tree baru, yaitu 't', maka tahapan yang harus dilakukan adalah : 1. t.leftChild = self.leftChild 2. self.leftChild = t Contoh : Berikut tambahan method pada class BinaryTree, untuk mendapatkan informasi mengenai left child, right child, dan root dari suatu binary tree class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key 2.Parsing Binary Tree Binary Tree Juga Dapat Digunakan Untuk Penyelesaina Persamaan matematika, penyelesaian persamaan matematika tergantung, pada operator dan keberadaan kurung, Jika terdapat tanda kurung buka maupun tutup, maka persamaan di dalam kurung tersebut haruslah diselesaikan pertama kali walapun level operator precedence lebih rendah dibandingkan operator yang berada di luar kurung Ada 2 Tahap Untuk penyelesaian persamaan matematika : Pembentukan Parse Tree Evaluasi Persamaan Matematika Pembuatan Parse Tree Persamaan Matematika harus dipecah menjadi list token agar dapat dibuat menjadi parse tree. Kurung buka, kurung buka ini menandakan ekspressi baru yang akan dioperasi, oleh karena itu perlu dibuat subtree baru untuk menyelesaikan ekspressi baru ini kurung tutup, kurung tutup ini menandakan akhir dari ekspressi matematika operand, operand ini yang akan jadi leaf node dan children dari operator operator, operator merupakan parent dan punya left maupun right child Algoritma : Jika current token adalah kurung buka, '(' , tambahkan node baru sebagai left child dari current Node dan jadikan node baru ini sebagai current node jika current token adalah operator, set nilai key dari current node dengan operator tersebut. Tambahkan node baru sebagai right child dari current node, jadikan right child ini sebagai current node jika current token adalah operand, maka set nilai key dari current node dengan operand tersebut dan jadikan parent dari node tersebut menjadi current node jika current token adalah kurung tutup, ')', maka kembali ke parent dari current node Contoh : Berikut code untuk parsing atau pembuatan binary tree untuk persamaan matematika. def stack(): s=[] return (s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return(len(s)) class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key def buildParseTree(mathExp): tokenList = mathExp.split() parentStack = stack() expTree = BinaryTree(' ' ) push(parentStack,expTree) print(tokenList) currentTree = expTree for i in tokenList: if i == '(' : print('if 1', i) currentTree.insertLeft(' ' ) push(parentStack,currentTree) currentTree = currentTree.getLeftChild() elif i not in [ '+' , '-' , '*' , '/' , ')' ]: print('if 2', i) currentTree.setRootVal(int(i)) parent = pop(parentStack) currentTree = parent elif i in [ '+' , '-' , '*' , '/' ]: print('if 3', i) currentTree.setRootVal(i) currentTree.insertRight(' ' ) push(parentStack,currentTree) currentTree = currentTree.getRightChild() elif i == ')' : currentTree = pop(parentStack) else: raise ValueError return expTree pt = buildParseTree(' ( 3 + ( 4 * 5 ) ) ') print(pt.getRootVal()) tmp=pt.getLeftChild() print(tmp.getRootVal()) if pt.getLeftChild(): print('Tree') Latihan Praktikum class BinaryTree: rightChild = None leftChild = None def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key def stack(): s=[] return (s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return(len(s)) import operator def evaluate(parse_tree): opers = { '+' :operator.add, '-' :operator.sub, '*' :operator.mul,'/' :operator.truediv} left = parse_tree.getLeftChild() right = parse_tree.getRightChild() if left and right: fn = opers[parse_tree.key] return fn(evaluate(left),evaluate(right)) else: return parse_tree.key def buildTree(i): s = stack() i = i.split() for x in i: if x in '1234567890': t = BinaryTree(x) push(s, t) elif x in '+-*/': sb = pop(s) sc = pop(s) a = BinaryTree(x) a.insertRight(sb.getRootVal()) a.insertLeft(sc.getRootVal()) push(s, a) return s[0] a = '2 8 9 + *' r = buildTree(a) print(evaluate(r))","title":"Materi 8 Binary Tree"},{"location":"materi8/#tree","text":"Pada materi sebelumnya kita telah belajar mengenai menyimpanan data secara linear, seperti hasing, stack, queue dan linked list. Pada mater kali ini kita akan mempelajari Tree yang memiliki cara penyimpanan data non-linear melainkan secara hierarki. Bagaimana maksudnya? Untuk mempermudahnya kita bayangkan saja susunan keluarga yang kita miliki. Jika diperhatikan dalam susunan tersebut kita akan menemukan siapa kakek kita, orang tua kita, saudara orang tua atau paman kita, sepepupu kita, saudara kita, atau bahkan cucu kita bukan? Begitulah kira - kira penggambarannya dari pengertian Tree penyimpanan data secara hierarki yang tersusun secara urut dari kakek hingga cucu. Berikut atribut - atribut yang terdapat dalam Tree : Node , merupakan bagian dari tree yang menyimpan informasi atau juga disebut sebagai key Edge yang menghubungkan antara node yang satu dengan yang lain. Hanya ada satu edge yang masuk ke dalam node, dan satu atau lebih edge yang keluar dari suatu node Root node yang terletak di paling atas, tidak ada edge yang masuk ke dalam node root ini, tapi root mempunyai satu atau lebih dari satu edge yang keluar. path merupakan urutan node dari root sampai tujuan, misalkan computer --> D: --> Mata Kuliah --> Struktur Data children , merupakan node-node yang memiliki edge yang masuk dari node yang sama. Misalkan program files, users, dan windows merupakan children, krn memiliki edge masuk yang sama-sama berasal dari node C: Parent node yang memiliki edge yang keluar dari node tersebut, misalkan node C: adalah parent dari program files, users, dan windows Siblings adalah node-node yang berasal dari parent yang sama subtree kumpulan dari node dan edge yang terdiri dari parent dan semua node setelah parent leaf node , node yang tidak memiliki edge yang keluar, node yang tidak memiliki children level , tingkatan dari node. Root merupakan level ke-0, semakin kebawah maka level dari node tersebut semakin besar, misalkan struktur data berada di level ke-3 height merupakan tinggi tree, nilai dari height ini adalah level maksimum dari tree","title":"Tree"},{"location":"materi8/#1-binary-tree","text":"Binary tree merupakan tree dimana setiap parent hanya memiliki dua buah atau satu node children saja. class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None myTree=BinaryTree(10) print(myTree.leftChild) Contoh : class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t Di mehod insertLeft perlu dilakukan pengecekan terlebih dahulu, apakah child kiri dari node yang akan disisipi subtree baru masih kosong, jika iya maka subtree tersebut dimasukkan pada leftChild. Dapat Menggunakan Perintah: self.leftChild=BinaryTree(new_node) Namun, jika setelah dilakukan pengecekan pada binary tree, ternyata leftChild tersebut tidak kosong, Misalkan terdapat tree 'u', dimana tree 'u' tersebut, memiliki leftchild, yaitu 'm'. Jika ingin dilakukan penyisipan tree baru, yaitu 't', maka tahapan yang harus dilakukan adalah : 1. t.leftChild = self.leftChild 2. self.leftChild = t Contoh : Berikut tambahan method pada class BinaryTree, untuk mendapatkan informasi mengenai left child, right child, dan root dari suatu binary tree class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key","title":"1. Binary Tree"},{"location":"materi8/#2parsing-binary-tree","text":"Binary Tree Juga Dapat Digunakan Untuk Penyelesaina Persamaan matematika, penyelesaian persamaan matematika tergantung, pada operator dan keberadaan kurung, Jika terdapat tanda kurung buka maupun tutup, maka persamaan di dalam kurung tersebut haruslah diselesaikan pertama kali walapun level operator precedence lebih rendah dibandingkan operator yang berada di luar kurung Ada 2 Tahap Untuk penyelesaian persamaan matematika : Pembentukan Parse Tree Evaluasi Persamaan Matematika","title":"2.Parsing Binary Tree"},{"location":"materi8/#pembuatan-parse-tree","text":"Persamaan Matematika harus dipecah menjadi list token agar dapat dibuat menjadi parse tree. Kurung buka, kurung buka ini menandakan ekspressi baru yang akan dioperasi, oleh karena itu perlu dibuat subtree baru untuk menyelesaikan ekspressi baru ini kurung tutup, kurung tutup ini menandakan akhir dari ekspressi matematika operand, operand ini yang akan jadi leaf node dan children dari operator operator, operator merupakan parent dan punya left maupun right child Algoritma : Jika current token adalah kurung buka, '(' , tambahkan node baru sebagai left child dari current Node dan jadikan node baru ini sebagai current node jika current token adalah operator, set nilai key dari current node dengan operator tersebut. Tambahkan node baru sebagai right child dari current node, jadikan right child ini sebagai current node jika current token adalah operand, maka set nilai key dari current node dengan operand tersebut dan jadikan parent dari node tersebut menjadi current node jika current token adalah kurung tutup, ')', maka kembali ke parent dari current node Contoh : Berikut code untuk parsing atau pembuatan binary tree untuk persamaan matematika. def stack(): s=[] return (s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return(len(s)) class BinaryTree: def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key def buildParseTree(mathExp): tokenList = mathExp.split() parentStack = stack() expTree = BinaryTree(' ' ) push(parentStack,expTree) print(tokenList) currentTree = expTree for i in tokenList: if i == '(' : print('if 1', i) currentTree.insertLeft(' ' ) push(parentStack,currentTree) currentTree = currentTree.getLeftChild() elif i not in [ '+' , '-' , '*' , '/' , ')' ]: print('if 2', i) currentTree.setRootVal(int(i)) parent = pop(parentStack) currentTree = parent elif i in [ '+' , '-' , '*' , '/' ]: print('if 3', i) currentTree.setRootVal(i) currentTree.insertRight(' ' ) push(parentStack,currentTree) currentTree = currentTree.getRightChild() elif i == ')' : currentTree = pop(parentStack) else: raise ValueError return expTree pt = buildParseTree(' ( 3 + ( 4 * 5 ) ) ') print(pt.getRootVal()) tmp=pt.getLeftChild() print(tmp.getRootVal()) if pt.getLeftChild(): print('Tree')","title":"Pembuatan Parse Tree"},{"location":"materi8/#latihan-praktikum","text":"class BinaryTree: rightChild = None leftChild = None def __init__(self, root): self.key = root self.leftChild = None self.rightChild = None def insertLeft(self, new_node): if self.leftChild == None: self.leftChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.leftChild = self.leftChild self.leftChild = t def insertRight(self, new_node): if self.rightChild == None: self.rightChild = BinaryTree(new_node) else: t = BinaryTree(new_node) t.rightChild = self.rightChild self.rightChild = t def getRightChild(self): return self.rightChild def getLeftChild(self): return self.leftChild def setRootVal(self, obj): self.key = obj def getRootVal(self): return self.key def stack(): s=[] return (s) def push(s,data): s.append(data) def pop(s): data=s.pop() return(data) def peek(s): return(s[len(s)-1]) def isEmpty(s): return (s==[]) def size(s): return(len(s)) import operator def evaluate(parse_tree): opers = { '+' :operator.add, '-' :operator.sub, '*' :operator.mul,'/' :operator.truediv} left = parse_tree.getLeftChild() right = parse_tree.getRightChild() if left and right: fn = opers[parse_tree.key] return fn(evaluate(left),evaluate(right)) else: return parse_tree.key def buildTree(i): s = stack() i = i.split() for x in i: if x in '1234567890': t = BinaryTree(x) push(s, t) elif x in '+-*/': sb = pop(s) sc = pop(s) a = BinaryTree(x) a.insertRight(sb.getRootVal()) a.insertLeft(sc.getRootVal()) push(s, a) return s[0] a = '2 8 9 + *' r = buildTree(a) print(evaluate(r))","title":"Latihan Praktikum"}]}